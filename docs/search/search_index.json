{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wasserstein Features The Wasserstein package computes Wasserstein distances and related quantities efficiently. It contains an efficient implementation of the network simplex algorithm originally from the LEMON graph library , modified by Nicolas Boneel , modified by the authors of the Python Optimal Transport (POT) library, and further modified in this package by Patrick Komiske. The main code is written in C++ with a NumPy-based Python wrapper provided via SWIG . To get started, check out the Python Binder Demo or the C++ Examples . The following classes contain the main functionalities of Wasserstein: EMD : Computes the Wasserstein distance between two distributions, including a possible penalty term. Can use either the builtin Euclidean ground distance (with the possibility of raising these to a power beta ) or a custom ground distance between distributions. PairwiseEMD : Computes pairs of Wasserstein distances between collections of distributions. Multi-threading support is provided via OMP. CorrelationDimension : The correlation dimension is a type of fractal dimension that estimates dimensionality of the underlying data manifold on which the distributions live. It has been applied to CMS Open Data . The current version is 1.1.0 . Changes are summarized in the Release Notes . Using the most up-to-date version is recommended. As of version 0.2.0 , tests have been written covering the majority of the code. The source code can be found on GitHub . References [1] N. Bonneel, M. van de Panne, S. Paris, W. Heidrich, Displacement interpolation using Lagrangian mass transport , ACM Trans. Graph. 30 (2011). [2] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Metric Space of Collider Events , Phys. Rev. Lett. 123 (2019) 041801 [ 1902.02346 ]. [3] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Hidden Geometry of Particle Collisions , JHEP 07 (2020) 006 [ 2004.04159 ]. Copyright Wasserstein is licensed under the GNU Puplic License v3 . See the LICENSE for detailed copyright information.","title":"Home"},{"location":"#welcome-to-wasserstein","text":"","title":"Welcome to Wasserstein"},{"location":"#features","text":"The Wasserstein package computes Wasserstein distances and related quantities efficiently. It contains an efficient implementation of the network simplex algorithm originally from the LEMON graph library , modified by Nicolas Boneel , modified by the authors of the Python Optimal Transport (POT) library, and further modified in this package by Patrick Komiske. The main code is written in C++ with a NumPy-based Python wrapper provided via SWIG . To get started, check out the Python Binder Demo or the C++ Examples . The following classes contain the main functionalities of Wasserstein: EMD : Computes the Wasserstein distance between two distributions, including a possible penalty term. Can use either the builtin Euclidean ground distance (with the possibility of raising these to a power beta ) or a custom ground distance between distributions. PairwiseEMD : Computes pairs of Wasserstein distances between collections of distributions. Multi-threading support is provided via OMP. CorrelationDimension : The correlation dimension is a type of fractal dimension that estimates dimensionality of the underlying data manifold on which the distributions live. It has been applied to CMS Open Data . The current version is 1.1.0 . Changes are summarized in the Release Notes . Using the most up-to-date version is recommended. As of version 0.2.0 , tests have been written covering the majority of the code. The source code can be found on GitHub .","title":"Features"},{"location":"#references","text":"[1] N. Bonneel, M. van de Panne, S. Paris, W. Heidrich, Displacement interpolation using Lagrangian mass transport , ACM Trans. Graph. 30 (2011). [2] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Metric Space of Collider Events , Phys. Rev. Lett. 123 (2019) 041801 [ 1902.02346 ]. [3] P. T. Komiske, E. M. Metodiev, and J. Thaler, The Hidden Geometry of Particle Collisions , JHEP 07 (2020) 006 [ 2004.04159 ].","title":"References"},{"location":"#copyright","text":"Wasserstein is licensed under the GNU Puplic License v3 . See the LICENSE for detailed copyright information.","title":"Copyright"},{"location":"demos/","text":"Interactive Demos The following Jupyter notebook demo is available on GitHub. Binder provides an awesome platform for running it durectly in your browser without installing anything whatsoever. For C++ usage, check out the Examples . Wasserstein Demo The Wasserstein Demo provides an introduction to using the Wasserstein package to compute Wasserstein/distances. View or download the notebook from GitHub","title":"Python Demos"},{"location":"demos/#interactive-demos","text":"The following Jupyter notebook demo is available on GitHub. Binder provides an awesome platform for running it durectly in your browser without installing anything whatsoever. For C++ usage, check out the Examples .","title":"Interactive Demos"},{"location":"demos/#wasserstein-demo","text":"The Wasserstein Demo provides an introduction to using the Wasserstein package to compute Wasserstein/distances. View or download the notebook from GitHub","title":"Wasserstein Demo"},{"location":"examples/","text":"Examples There are 4 C++ examples provided for the Wasserstein package. They can be downloaded from GitHub with associated files and a Makefile. emd_example.cpp //------------------------------------------------------------------------ // This file is part of Wasserstein, a C++ library with a Python wrapper // that computes the Wasserstein/EMD distance. If you use it for academic // research, please cite or acknowledge the following works: // // - Komiske, Metodiev, Thaler (2019) arXiv:1902.02346 // https://doi.org/10.1103/PhysRevLett.123.041801 // - Komiske, Metodiev, Thaler (2020) arXiv:2004.04159 // https://doi.org/10.1007/JHEP07%282020%29006 // - Boneel, van de Panne, Paris, Heidrich (2011) // https://doi.org/10.1145/2070781.2024192 // - LEMON graph library https://lemon.cs.elte.hu/trac/lemon // // Copyright (C) 2019-2021 Patrick T. Komiske III // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program. If not, see <https://www.gnu.org/licenses/>. //------------------------------------------------------------------------ // Wasserstein library #include \"Wasserstein.hh\" // classes and functions for reading/preparing events #include \"ExampleUtils.hh\" // `EMDFloat64` uses `double` for the floating-point type // first template parameter is an Event type, second is a PairwiseDistance type using EMD = emd :: EMDFloat64 < emd :: EuclideanEvent2D , emd :: YPhiParticleDistance > ; // the `EuclideanParticle[N]D` classes provide a simple container for weighted particles using EMDParticle = emd :: EuclideanParticle2D <> ; int main ( int argc , char ** argv ) { // load events EventProducer * evp ( load_events ( argc , argv )); if ( evp == nullptr ) return 1 ; // demonstrate calculating single EMDs EMD emd_obj ( 0.4 , 1.0 , true ); // preprocess events to center emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << emd_obj . description () << std :: endl ; // container to hold emd values std :: vector < double > emds ; // loop over events and compute the EMD between each successive pair evp -> reset (); while ( true ) { // get first event if ( ! evp -> next ()) break ; auto event0 ( convert2event < EMDParticle > ( evp -> particles ())); // get second event if ( ! evp -> next ()) break ; auto event1 ( convert2event < EMDParticle > ( evp -> particles ())); // compute emd and add it to vector emds . push_back ( emd_obj ( event0 , event1 )); } // get max and min EMD value std :: cout << '\\n' << emds . size () << \" EMDs computed \\n \" << \"Min. EMD - \" << * std :: min_element ( emds . begin (), emds . end ()) << '\\n' << \"Max. EMD - \" << * std :: max_element ( emds . begin (), emds . end ()) << '\\n' << '\\n' ; return 0 ; } pairwise_emds_example.cpp //------------------------------------------------------------------------ // This file is part of Wasserstein, a C++ library with a Python wrapper // that computes the Wasserstein/EMD distance. If you use it for academic // research, please cite or acknowledge the following works: // // - Komiske, Metodiev, Thaler (2019) arXiv:1902.02346 // https://doi.org/10.1103/PhysRevLett.123.041801 // - Komiske, Metodiev, Thaler (2020) arXiv:2004.04159 // https://doi.org/10.1007/JHEP07%282020%29006 // - Boneel, van de Panne, Paris, Heidrich (2011) // https://doi.org/10.1145/2070781.2024192 // - LEMON graph library https://lemon.cs.elte.hu/trac/lemon // // Copyright (C) 2019-2021 Patrick T. Komiske III // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program. If not, see <https://www.gnu.org/licenses/>. //------------------------------------------------------------------------ // Wasserstein library #include \"Wasserstein.hh\" // classes and functions for reading/preparing events #include \"ExampleUtils.hh\" // `EMDFloat64` uses `double` for the floating-point type // first template parameter is an Event type, second is a PairwiseDistance type using EMD = emd :: EMDFloat64 < emd :: EuclideanEvent2D , emd :: YPhiParticleDistance > ; // `PairwiseEMD` is a templated class accepting a fully qualified `EMD` type using PairwiseEMD = emd :: PairwiseEMD < EMD > ; // empty angle brackets use the default floating-point type `double` using CorrelationDimension = emd :: CorrelationDimension <> ; // the `EuclideanParticle[N]D` classes provide a simple container for weighted particles using EMDParticle = emd :: EuclideanParticle2D <> ; int main ( int argc , char ** argv ) { // load events EventProducer * evp ( load_events ( argc , argv )); if ( evp == nullptr ) return 1 ; // demonstrate calculating pairwise EMDs PairwiseEMD pairwise_emd_obj ( 0.4 , 1.0 , false ); // preprocess events to center pairwise_emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << pairwise_emd_obj . description () << std :: endl ; // get vector of events std :: vector < std :: vector < EMDParticle >> events ; // loop over events and compute the EMD between each successive pair evp -> reset (); for ( int i = 0 ; i < 1000 && evp -> next (); i ++ ) events . push_back ( convert2event < EMDParticle > ( evp -> particles ())); // run computation pairwise_emd_obj ( events ); // get max and min EMD value const std :: vector < double > & emds ( pairwise_emd_obj . emds ( true )); std :: cout << \"Min. EMD - \" << * std :: min_element ( emds . begin (), emds . end ()) << '\\n' << \"Max. EMD - \" << * std :: max_element ( emds . begin (), emds . end ()) << '\\n' << '\\n' ; // setup correlation dimension CorrelationDimension corrdim ( 50 , 10. , 250. ); pairwise_emd_obj . set_external_emd_handler ( corrdim ); // rerun computation pairwise_emd_obj ( events ); // print out correlation dimensions auto corrdims ( corrdim . corrdims ()); auto corrdim_bins ( corrdim . corrdim_bins ()); std :: cout << \" \\n EMD Corr. Dim. Error \\n \" << std :: left ; for ( unsigned i = 0 ; i < corrdims . first . size (); i ++ ) std :: cout << std :: setw ( 12 ) << corrdim_bins [ i ] << std :: setw ( 12 ) << corrdims . first [ i ] << std :: setw ( 12 ) << corrdims . second [ i ] << '\\n' ; return 0 ; } serialization_example.cpp //------------------------------------------------------------------------ // This file is part of Wasserstein, a C++ library with a Python wrapper // that computes the Wasserstein/EMD distance. If you use it for academic // research, please cite or acknowledge the following works: // // - Komiske, Metodiev, Thaler (2019) arXiv:1902.02346 // https://doi.org/10.1103/PhysRevLett.123.041801 // - Komiske, Metodiev, Thaler (2020) arXiv:2004.04159 // https://doi.org/10.1007/JHEP07%282020%29006 // - Boneel, van de Panne, Paris, Heidrich (2011) // https://doi.org/10.1145/2070781.2024192 // - LEMON graph library https://lemon.cs.elte.hu/trac/lemon // // Copyright (C) 2019-2021 Patrick T. Komiske III // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program. If not, see <https://www.gnu.org/licenses/>. //------------------------------------------------------------------------ // Wasserstein library #define WASSERSTEIN_SERIALIZATION #include \"Wasserstein.hh\" // classes and functions for reading/preparing events #include \"ExampleUtils.hh\" // `EMDFloat64` uses `double` for the floating-point type // first template parameter is an Event type, second is a PairwiseDistance type using EMD = emd :: EMDFloat64 < emd :: EuclideanEvent2D , emd :: YPhiParticleDistance > ; // `PairwiseEMD` is a templated class accepting a fully qualified `EMD` type using PairwiseEMD = emd :: PairwiseEMD < EMD > ; // empty angle brackets use the default floating-point type `double` using CorrelationDimension = emd :: CorrelationDimension <> ; // the `EuclideanParticle[N]D` classes provide a simple container for weighted particles using EMDParticle = emd :: EuclideanParticle2D <> ; int main ( int argc , char ** argv ) { // load events EventProducer * evp ( load_events ( argc , argv )); if ( evp == nullptr ) return 1 ; //////////////////////////// // EMD Serialization //////////////////////////// // demonstrate calculating single EMDs EMD emd_obj ( 0.4 , 1.0 , true ); // preprocess events to center emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << emd_obj . description () << std :: endl ; // serialize std :: stringstream ss ; boost :: archive :: text_oarchive oa ( ss ); oa << emd_obj ; // extract boost :: archive :: text_iarchive ia ( ss ); EMD new_emd_obj ; ia >> new_emd_obj ; // print EMD description std :: cout << new_emd_obj . description () << \"Note that preprocessors are not currently preserved in serialized objects\" << std :: endl ; ///////////////////////////////////////////////////// // PairwiseEMD and CorrelationDimension Serialization ///////////////////////////////////////////////////// // demonstrate calculating pairwise EMDs PairwiseEMD pairwise_emd_obj ( 0.4 , 1.0 , false ); // preprocess events to center pairwise_emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << pairwise_emd_obj . description () << std :: endl ; // get vector of events std :: vector < std :: vector < EMDParticle >> events ; // loop over events and compute the EMD between each successive pair evp -> reset (); for ( int i = 0 ; i < 1000 && evp -> next (); i ++ ) events . push_back ( convert2event < EMDParticle > ( evp -> particles ())); // setup correlation dimension CorrelationDimension corrdim ( 50 , 10. , 250. ); pairwise_emd_obj . set_external_emd_handler ( corrdim ); // run computation pairwise_emd_obj ( events ); // serialize std :: stringstream ss2 ; boost :: archive :: text_oarchive oa2 ( ss2 ); oa2 << pairwise_emd_obj << corrdim ; // define empty objects PairwiseEMD new_pairwise_emd_obj ; CorrelationDimension new_corrdim ; // extract boost :: archive :: text_iarchive ia2 ( ss2 ); ia2 >> new_pairwise_emd_obj >> new_corrdim ; // print PairwiseEMD description std :: cout << new_pairwise_emd_obj . description () << \"Note that preprocessors are not currently preserved in serialized objects\" << std :: endl ; // print out correlation dimensions auto corrdims ( new_corrdim . corrdims ()); auto corrdim_bins ( new_corrdim . corrdim_bins ()); std :: cout << \" \\n EMD Corr. Dim. Error \\n \" << std :: left ; for ( unsigned i = 0 ; i < corrdims . first . size (); i ++ ) std :: cout << std :: setw ( 12 ) << corrdim_bins [ i ] << std :: setw ( 12 ) << corrdims . first [ i ] << std :: setw ( 12 ) << corrdims . second [ i ] << '\\n' ; } theory_space_example.cpp //------------------------------------------------------------------------ // This file is part of Wasserstein, a C++ library with a Python wrapper // that computes the Wasserstein/EMD distance. If you use it for academic // research, please cite or acknowledge the following works: // // - Komiske, Metodiev, Thaler (2019) arXiv:1902.02346 // https://doi.org/10.1103/PhysRevLett.123.041801 // - Komiske, Metodiev, Thaler (2020) arXiv:2004.04159 // https://doi.org/10.1007/JHEP07%282020%29006 // - Boneel, van de Panne, Paris, Heidrich (2011) // https://doi.org/10.1145/2070781.2024192 // - LEMON graph library https://lemon.cs.elte.hu/trac/lemon // // Copyright (C) 2019-2021 Patrick T. Komiske III // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program. If not, see <https://www.gnu.org/licenses/>. //------------------------------------------------------------------------ // Wasserstein library #include \"Wasserstein.hh\" // classes and functions for reading/preparing events #include \"ExampleUtils.hh\" // `EMDFloat64` uses `double` for the floating-point type // first template parameter is an Event type, second is a PairwiseDistance type using EMD = emd :: EMDFloat64 < emd :: EuclideanEvent2D , emd :: YPhiParticleDistance > ; // `PairwiseEMD` is a templated class accepting a fully qualified `EMD` type using PairwiseEMD = emd :: PairwiseEMD < EMD > ; // the `EuclideanParticle[N]D` classes provide a simple container for weighted particles using EMDParticle = emd :: EuclideanParticle2D <> ; int main ( int argc , char ** argv ) { // load events EventProducer * evp ( load_events ( argc , argv )); if ( evp == nullptr ) return 1 ; // demonstrate some EMD usage double EMD_R = 0.4 ; double EMD_beta = 1 ; bool EMD_norm = true ; PairwiseEMD pairwise_emd_obj ( EMD_R , EMD_beta , EMD_norm ); // preprocess events to center pairwise_emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << pairwise_emd_obj . description () << std :: endl ; // get vector of events std :: vector < std :: vector < EMDParticle >> events ; // loop over events and compute the EMD between each successive pair evp -> reset (); while ( evp -> next ()) events . push_back ( convert2event < EMDParticle > ( evp -> particles ())); // run computation pairwise_emd_obj ( events . begin (), events . begin () + evp -> num_accepted () / 2 , events . begin () + evp -> num_accepted () / 2 , events . end ()); // get max and min EMD value const std :: vector < double > & emds_raw ( pairwise_emd_obj . emds ()); std :: cout << \"Min. EMD - \" << * std :: min_element ( emds_raw . begin (), emds_raw . end ()) << '\\n' << \"Max. EMD - \" << * std :: max_element ( emds_raw . begin (), emds_raw . end ()) << '\\n' << emds_raw . size () << \" emds \\n \" << '\\n' ; // setup EMD object to compute cross section mover's distance double SigmaMD_R = 1 ; double SigmaMD_beta = 1 ; bool SigmaMD_norm = true ; bool SigmaMD_do_timing = true ; // external dists are used by the default configuration emd :: EMDFloat64 <> sigmamd_obj ( SigmaMD_R , SigmaMD_beta , SigmaMD_norm , SigmaMD_do_timing ); std :: cout << sigmamd_obj . description () << '\\n' ; // set distances auto emds ( pairwise_emd_obj . emds ()); sigmamd_obj . ground_dists (). resize ( emds . size ()); for ( std :: size_t i = 0 ; i < emds . size (); i ++ ) sigmamd_obj . ground_dists ()[ i ] = emds [ i ]; // form datasets std :: vector < double > weights0 ( pairwise_emd_obj . nevA (), 1 ), weights1 ( pairwise_emd_obj . nevB (), 1 ); std :: cout << \"Running computation ...\" << std :: endl ; // run computation std :: cout << \"Cross-section Mover's Distance : \" << sigmamd_obj ( weights0 , weights1 ) << '\\n' << \"Done in \" << sigmamd_obj . duration () << \"s \\n \" ; return 0 ; }","title":"C++ Examples"},{"location":"examples/#examples","text":"There are 4 C++ examples provided for the Wasserstein package. They can be downloaded from GitHub with associated files and a Makefile.","title":"Examples"},{"location":"examples/#emd_examplecpp","text":"//------------------------------------------------------------------------ // This file is part of Wasserstein, a C++ library with a Python wrapper // that computes the Wasserstein/EMD distance. If you use it for academic // research, please cite or acknowledge the following works: // // - Komiske, Metodiev, Thaler (2019) arXiv:1902.02346 // https://doi.org/10.1103/PhysRevLett.123.041801 // - Komiske, Metodiev, Thaler (2020) arXiv:2004.04159 // https://doi.org/10.1007/JHEP07%282020%29006 // - Boneel, van de Panne, Paris, Heidrich (2011) // https://doi.org/10.1145/2070781.2024192 // - LEMON graph library https://lemon.cs.elte.hu/trac/lemon // // Copyright (C) 2019-2021 Patrick T. Komiske III // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program. If not, see <https://www.gnu.org/licenses/>. //------------------------------------------------------------------------ // Wasserstein library #include \"Wasserstein.hh\" // classes and functions for reading/preparing events #include \"ExampleUtils.hh\" // `EMDFloat64` uses `double` for the floating-point type // first template parameter is an Event type, second is a PairwiseDistance type using EMD = emd :: EMDFloat64 < emd :: EuclideanEvent2D , emd :: YPhiParticleDistance > ; // the `EuclideanParticle[N]D` classes provide a simple container for weighted particles using EMDParticle = emd :: EuclideanParticle2D <> ; int main ( int argc , char ** argv ) { // load events EventProducer * evp ( load_events ( argc , argv )); if ( evp == nullptr ) return 1 ; // demonstrate calculating single EMDs EMD emd_obj ( 0.4 , 1.0 , true ); // preprocess events to center emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << emd_obj . description () << std :: endl ; // container to hold emd values std :: vector < double > emds ; // loop over events and compute the EMD between each successive pair evp -> reset (); while ( true ) { // get first event if ( ! evp -> next ()) break ; auto event0 ( convert2event < EMDParticle > ( evp -> particles ())); // get second event if ( ! evp -> next ()) break ; auto event1 ( convert2event < EMDParticle > ( evp -> particles ())); // compute emd and add it to vector emds . push_back ( emd_obj ( event0 , event1 )); } // get max and min EMD value std :: cout << '\\n' << emds . size () << \" EMDs computed \\n \" << \"Min. EMD - \" << * std :: min_element ( emds . begin (), emds . end ()) << '\\n' << \"Max. EMD - \" << * std :: max_element ( emds . begin (), emds . end ()) << '\\n' << '\\n' ; return 0 ; }","title":"emd_example.cpp"},{"location":"examples/#pairwise_emds_examplecpp","text":"//------------------------------------------------------------------------ // This file is part of Wasserstein, a C++ library with a Python wrapper // that computes the Wasserstein/EMD distance. If you use it for academic // research, please cite or acknowledge the following works: // // - Komiske, Metodiev, Thaler (2019) arXiv:1902.02346 // https://doi.org/10.1103/PhysRevLett.123.041801 // - Komiske, Metodiev, Thaler (2020) arXiv:2004.04159 // https://doi.org/10.1007/JHEP07%282020%29006 // - Boneel, van de Panne, Paris, Heidrich (2011) // https://doi.org/10.1145/2070781.2024192 // - LEMON graph library https://lemon.cs.elte.hu/trac/lemon // // Copyright (C) 2019-2021 Patrick T. Komiske III // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program. If not, see <https://www.gnu.org/licenses/>. //------------------------------------------------------------------------ // Wasserstein library #include \"Wasserstein.hh\" // classes and functions for reading/preparing events #include \"ExampleUtils.hh\" // `EMDFloat64` uses `double` for the floating-point type // first template parameter is an Event type, second is a PairwiseDistance type using EMD = emd :: EMDFloat64 < emd :: EuclideanEvent2D , emd :: YPhiParticleDistance > ; // `PairwiseEMD` is a templated class accepting a fully qualified `EMD` type using PairwiseEMD = emd :: PairwiseEMD < EMD > ; // empty angle brackets use the default floating-point type `double` using CorrelationDimension = emd :: CorrelationDimension <> ; // the `EuclideanParticle[N]D` classes provide a simple container for weighted particles using EMDParticle = emd :: EuclideanParticle2D <> ; int main ( int argc , char ** argv ) { // load events EventProducer * evp ( load_events ( argc , argv )); if ( evp == nullptr ) return 1 ; // demonstrate calculating pairwise EMDs PairwiseEMD pairwise_emd_obj ( 0.4 , 1.0 , false ); // preprocess events to center pairwise_emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << pairwise_emd_obj . description () << std :: endl ; // get vector of events std :: vector < std :: vector < EMDParticle >> events ; // loop over events and compute the EMD between each successive pair evp -> reset (); for ( int i = 0 ; i < 1000 && evp -> next (); i ++ ) events . push_back ( convert2event < EMDParticle > ( evp -> particles ())); // run computation pairwise_emd_obj ( events ); // get max and min EMD value const std :: vector < double > & emds ( pairwise_emd_obj . emds ( true )); std :: cout << \"Min. EMD - \" << * std :: min_element ( emds . begin (), emds . end ()) << '\\n' << \"Max. EMD - \" << * std :: max_element ( emds . begin (), emds . end ()) << '\\n' << '\\n' ; // setup correlation dimension CorrelationDimension corrdim ( 50 , 10. , 250. ); pairwise_emd_obj . set_external_emd_handler ( corrdim ); // rerun computation pairwise_emd_obj ( events ); // print out correlation dimensions auto corrdims ( corrdim . corrdims ()); auto corrdim_bins ( corrdim . corrdim_bins ()); std :: cout << \" \\n EMD Corr. Dim. Error \\n \" << std :: left ; for ( unsigned i = 0 ; i < corrdims . first . size (); i ++ ) std :: cout << std :: setw ( 12 ) << corrdim_bins [ i ] << std :: setw ( 12 ) << corrdims . first [ i ] << std :: setw ( 12 ) << corrdims . second [ i ] << '\\n' ; return 0 ; }","title":"pairwise_emds_example.cpp"},{"location":"examples/#serialization_examplecpp","text":"//------------------------------------------------------------------------ // This file is part of Wasserstein, a C++ library with a Python wrapper // that computes the Wasserstein/EMD distance. If you use it for academic // research, please cite or acknowledge the following works: // // - Komiske, Metodiev, Thaler (2019) arXiv:1902.02346 // https://doi.org/10.1103/PhysRevLett.123.041801 // - Komiske, Metodiev, Thaler (2020) arXiv:2004.04159 // https://doi.org/10.1007/JHEP07%282020%29006 // - Boneel, van de Panne, Paris, Heidrich (2011) // https://doi.org/10.1145/2070781.2024192 // - LEMON graph library https://lemon.cs.elte.hu/trac/lemon // // Copyright (C) 2019-2021 Patrick T. Komiske III // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program. If not, see <https://www.gnu.org/licenses/>. //------------------------------------------------------------------------ // Wasserstein library #define WASSERSTEIN_SERIALIZATION #include \"Wasserstein.hh\" // classes and functions for reading/preparing events #include \"ExampleUtils.hh\" // `EMDFloat64` uses `double` for the floating-point type // first template parameter is an Event type, second is a PairwiseDistance type using EMD = emd :: EMDFloat64 < emd :: EuclideanEvent2D , emd :: YPhiParticleDistance > ; // `PairwiseEMD` is a templated class accepting a fully qualified `EMD` type using PairwiseEMD = emd :: PairwiseEMD < EMD > ; // empty angle brackets use the default floating-point type `double` using CorrelationDimension = emd :: CorrelationDimension <> ; // the `EuclideanParticle[N]D` classes provide a simple container for weighted particles using EMDParticle = emd :: EuclideanParticle2D <> ; int main ( int argc , char ** argv ) { // load events EventProducer * evp ( load_events ( argc , argv )); if ( evp == nullptr ) return 1 ; //////////////////////////// // EMD Serialization //////////////////////////// // demonstrate calculating single EMDs EMD emd_obj ( 0.4 , 1.0 , true ); // preprocess events to center emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << emd_obj . description () << std :: endl ; // serialize std :: stringstream ss ; boost :: archive :: text_oarchive oa ( ss ); oa << emd_obj ; // extract boost :: archive :: text_iarchive ia ( ss ); EMD new_emd_obj ; ia >> new_emd_obj ; // print EMD description std :: cout << new_emd_obj . description () << \"Note that preprocessors are not currently preserved in serialized objects\" << std :: endl ; ///////////////////////////////////////////////////// // PairwiseEMD and CorrelationDimension Serialization ///////////////////////////////////////////////////// // demonstrate calculating pairwise EMDs PairwiseEMD pairwise_emd_obj ( 0.4 , 1.0 , false ); // preprocess events to center pairwise_emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << pairwise_emd_obj . description () << std :: endl ; // get vector of events std :: vector < std :: vector < EMDParticle >> events ; // loop over events and compute the EMD between each successive pair evp -> reset (); for ( int i = 0 ; i < 1000 && evp -> next (); i ++ ) events . push_back ( convert2event < EMDParticle > ( evp -> particles ())); // setup correlation dimension CorrelationDimension corrdim ( 50 , 10. , 250. ); pairwise_emd_obj . set_external_emd_handler ( corrdim ); // run computation pairwise_emd_obj ( events ); // serialize std :: stringstream ss2 ; boost :: archive :: text_oarchive oa2 ( ss2 ); oa2 << pairwise_emd_obj << corrdim ; // define empty objects PairwiseEMD new_pairwise_emd_obj ; CorrelationDimension new_corrdim ; // extract boost :: archive :: text_iarchive ia2 ( ss2 ); ia2 >> new_pairwise_emd_obj >> new_corrdim ; // print PairwiseEMD description std :: cout << new_pairwise_emd_obj . description () << \"Note that preprocessors are not currently preserved in serialized objects\" << std :: endl ; // print out correlation dimensions auto corrdims ( new_corrdim . corrdims ()); auto corrdim_bins ( new_corrdim . corrdim_bins ()); std :: cout << \" \\n EMD Corr. Dim. Error \\n \" << std :: left ; for ( unsigned i = 0 ; i < corrdims . first . size (); i ++ ) std :: cout << std :: setw ( 12 ) << corrdim_bins [ i ] << std :: setw ( 12 ) << corrdims . first [ i ] << std :: setw ( 12 ) << corrdims . second [ i ] << '\\n' ; }","title":"serialization_example.cpp"},{"location":"examples/#theory_space_examplecpp","text":"//------------------------------------------------------------------------ // This file is part of Wasserstein, a C++ library with a Python wrapper // that computes the Wasserstein/EMD distance. If you use it for academic // research, please cite or acknowledge the following works: // // - Komiske, Metodiev, Thaler (2019) arXiv:1902.02346 // https://doi.org/10.1103/PhysRevLett.123.041801 // - Komiske, Metodiev, Thaler (2020) arXiv:2004.04159 // https://doi.org/10.1007/JHEP07%282020%29006 // - Boneel, van de Panne, Paris, Heidrich (2011) // https://doi.org/10.1145/2070781.2024192 // - LEMON graph library https://lemon.cs.elte.hu/trac/lemon // // Copyright (C) 2019-2021 Patrick T. Komiske III // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License // along with this program. If not, see <https://www.gnu.org/licenses/>. //------------------------------------------------------------------------ // Wasserstein library #include \"Wasserstein.hh\" // classes and functions for reading/preparing events #include \"ExampleUtils.hh\" // `EMDFloat64` uses `double` for the floating-point type // first template parameter is an Event type, second is a PairwiseDistance type using EMD = emd :: EMDFloat64 < emd :: EuclideanEvent2D , emd :: YPhiParticleDistance > ; // `PairwiseEMD` is a templated class accepting a fully qualified `EMD` type using PairwiseEMD = emd :: PairwiseEMD < EMD > ; // the `EuclideanParticle[N]D` classes provide a simple container for weighted particles using EMDParticle = emd :: EuclideanParticle2D <> ; int main ( int argc , char ** argv ) { // load events EventProducer * evp ( load_events ( argc , argv )); if ( evp == nullptr ) return 1 ; // demonstrate some EMD usage double EMD_R = 0.4 ; double EMD_beta = 1 ; bool EMD_norm = true ; PairwiseEMD pairwise_emd_obj ( EMD_R , EMD_beta , EMD_norm ); // preprocess events to center pairwise_emd_obj . preprocess < emd :: CenterWeightedCentroid > (); // print description std :: cout << pairwise_emd_obj . description () << std :: endl ; // get vector of events std :: vector < std :: vector < EMDParticle >> events ; // loop over events and compute the EMD between each successive pair evp -> reset (); while ( evp -> next ()) events . push_back ( convert2event < EMDParticle > ( evp -> particles ())); // run computation pairwise_emd_obj ( events . begin (), events . begin () + evp -> num_accepted () / 2 , events . begin () + evp -> num_accepted () / 2 , events . end ()); // get max and min EMD value const std :: vector < double > & emds_raw ( pairwise_emd_obj . emds ()); std :: cout << \"Min. EMD - \" << * std :: min_element ( emds_raw . begin (), emds_raw . end ()) << '\\n' << \"Max. EMD - \" << * std :: max_element ( emds_raw . begin (), emds_raw . end ()) << '\\n' << emds_raw . size () << \" emds \\n \" << '\\n' ; // setup EMD object to compute cross section mover's distance double SigmaMD_R = 1 ; double SigmaMD_beta = 1 ; bool SigmaMD_norm = true ; bool SigmaMD_do_timing = true ; // external dists are used by the default configuration emd :: EMDFloat64 <> sigmamd_obj ( SigmaMD_R , SigmaMD_beta , SigmaMD_norm , SigmaMD_do_timing ); std :: cout << sigmamd_obj . description () << '\\n' ; // set distances auto emds ( pairwise_emd_obj . emds ()); sigmamd_obj . ground_dists (). resize ( emds . size ()); for ( std :: size_t i = 0 ; i < emds . size (); i ++ ) sigmamd_obj . ground_dists ()[ i ] = emds [ i ]; // form datasets std :: vector < double > weights0 ( pairwise_emd_obj . nevA (), 1 ), weights1 ( pairwise_emd_obj . nevB (), 1 ); std :: cout << \"Running computation ...\" << std :: endl ; // run computation std :: cout << \"Cross-section Mover's Distance : \" << sigmamd_obj ( weights0 , weights1 ) << '\\n' << \"Done in \" << sigmamd_obj . duration () << \"s \\n \" ; return 0 ; }","title":"theory_space_example.cpp"},{"location":"faqs/","text":"Frequently Asked EnergyFlow Questions Why should I use Wasserstein instead of the Python Optimal Transport (POT) library? How do I cite the Wasserstein package? Where can I get the code? How do I report an issue or a bug? Why should I use Wasserstein instead of the Python Optimal Transport (POT) library? POT offers EMD functionality based on the same algorithm as Wasserstein. You'll find that Wasserstein is faster (up to 2x) for small problems (around 100 particles) due to the more efficient way in which we interface with NumPy. Also, Wasserstein offers greater numerical flexibility, with the ability to control certain floating point epsilons that POT hard codes and can cause failure (especially on macOS, we have found). And then there is the C++ interface that Wasserstein exposes in case you work in that language. How do I cite the Wasserstein package? Please cite the relevant papers if they or this package help your research. Here are the BibTeX entries to use: @article { 10.1145/2070781.2024192 , author = \"Bonneel, Nicolas and van de Panne, Michiel and Paris, Sylvain and Heidrich, Wolfgang\" , title = \"{Displacement Interpolation Using Lagrangian Mass Transport}\" , year = \"2011\" , issue_date = \"December 2011\" , publisher = \"Association for Computing Machinery\" , address = \"New York, NY, USA\" , volume = \"30\" , number = \"6\" , issn = \"0730-0301\" , url = \"https://doi.org/10.1145/2070781.2024192\" , doi = \"10.1145/2070781.2024192\" , journal = \"ACM Trans. Graph.\" , month = \"dec\" , pages = \"1\u201312\" , numpages = \"12\" } @article { Komiske:2019fks , author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\" , title = \"{Metric Space of Collider Events}\" , eprint = \"1902.02346\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , reportNumber = \"MIT-CTP 5102\" , doi = \"10.1103/PhysRevLett.123.041801\" , journal = \"Phys. Rev. Lett.\" , volume = \"123\" , number = \"4\" , pages = \"041801\" , year = \"2019\" } @article { Komiske:2020qhg , author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\" , title = \"{The Hidden Geometry of Particle Collisions}\" , eprint = \"2004.04159\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , reportNumber = \"MIT-CTP 5185\" , doi = \"10.1007/JHEP07(2020)006\" , journal = \"JHEP\" , volume = \"07\" , pages = \"006\" , year = \"2020\" } Where can I get the code? The code is open source and hosted on GitHub . How do I report an issue? Please report any issues you encounter by creating a GitHub Issue .","title":"FAQs"},{"location":"faqs/#frequently-asked-energyflow-questions","text":"Why should I use Wasserstein instead of the Python Optimal Transport (POT) library? How do I cite the Wasserstein package? Where can I get the code? How do I report an issue or a bug?","title":"Frequently Asked EnergyFlow Questions"},{"location":"faqs/#why-should-i-use-wasserstein-instead-of-the-python-optimal-transport-pot-library","text":"POT offers EMD functionality based on the same algorithm as Wasserstein. You'll find that Wasserstein is faster (up to 2x) for small problems (around 100 particles) due to the more efficient way in which we interface with NumPy. Also, Wasserstein offers greater numerical flexibility, with the ability to control certain floating point epsilons that POT hard codes and can cause failure (especially on macOS, we have found). And then there is the C++ interface that Wasserstein exposes in case you work in that language.","title":"Why should I use Wasserstein instead of the Python Optimal Transport (POT) library?"},{"location":"faqs/#how-do-i-cite-the-wasserstein-package","text":"Please cite the relevant papers if they or this package help your research. Here are the BibTeX entries to use: @article { 10.1145/2070781.2024192 , author = \"Bonneel, Nicolas and van de Panne, Michiel and Paris, Sylvain and Heidrich, Wolfgang\" , title = \"{Displacement Interpolation Using Lagrangian Mass Transport}\" , year = \"2011\" , issue_date = \"December 2011\" , publisher = \"Association for Computing Machinery\" , address = \"New York, NY, USA\" , volume = \"30\" , number = \"6\" , issn = \"0730-0301\" , url = \"https://doi.org/10.1145/2070781.2024192\" , doi = \"10.1145/2070781.2024192\" , journal = \"ACM Trans. Graph.\" , month = \"dec\" , pages = \"1\u201312\" , numpages = \"12\" } @article { Komiske:2019fks , author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\" , title = \"{Metric Space of Collider Events}\" , eprint = \"1902.02346\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , reportNumber = \"MIT-CTP 5102\" , doi = \"10.1103/PhysRevLett.123.041801\" , journal = \"Phys. Rev. Lett.\" , volume = \"123\" , number = \"4\" , pages = \"041801\" , year = \"2019\" } @article { Komiske:2020qhg , author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\" , title = \"{The Hidden Geometry of Particle Collisions}\" , eprint = \"2004.04159\" , archivePrefix = \"arXiv\" , primaryClass = \"hep-ph\" , reportNumber = \"MIT-CTP 5185\" , doi = \"10.1007/JHEP07(2020)006\" , journal = \"JHEP\" , volume = \"07\" , pages = \"006\" , year = \"2020\" }","title":"How do I cite the Wasserstein package?"},{"location":"faqs/#where-can-i-get-the-code","text":"The code is open source and hosted on GitHub .","title":"Where can I get the code?"},{"location":"faqs/#how-do-i-report-an-issue","text":"Please report any issues you encounter by creating a GitHub Issue .","title":"How do I report an issue?"},{"location":"installation/","text":"Installation The Wasserstein package can be used as a header-only C++ template library or as a Python package that wraps the C++ code. Python Install via pip Precompiled Python wheels are available for Linux, maxOS, and Windows via PyPI. The only strict dependency is NumPy, though Wurlitzer is also installed in order to redirect standard output into Jupyter notebooks in the demos. Simply run the following in a terminal to install Wasserstein: pip3 install wasserstein Install from Python source The only reason to bother with the source code when using Wasserstein in Python is if one wants to develop some feature in the package. The Wasserstein source code can be obtained from GitHub . Running python3 setup.py swig (which requires the swig binary to be available on the path) will regenerate the Python wrapper code. Running python3 setup.py build_ext --inplace will compile the library, and pip3 install -e . will install a development version pointing to the current directory. C++ The Wasserstein source code can be obtained from GitHub . Since the library is header-only, no compilation is required to install it. The provided install_wasserstein.sh script can be used (on a UNIX-like system, at least) to move the requisite header files to an appropriate location such as /usr/local/include . If your system does not have the Boost libraries (version 1.70.0 or newer is required to access the histogram package) available, set the second argument to true in order to use the provided Boost Histogram header files. Try the following in order to move the Wasserstein header files to an installed location, in this case /usr/local/include : git clone https://github.com/pkomiske/Wasserstein cd Wasserstein chmod +x install_wasserstein.sh ./install_wasserstein /usr/local false","title":"Installation"},{"location":"installation/#installation","text":"The Wasserstein package can be used as a header-only C++ template library or as a Python package that wraps the C++ code.","title":"Installation"},{"location":"installation/#python","text":"","title":"Python"},{"location":"installation/#install-via-pip","text":"Precompiled Python wheels are available for Linux, maxOS, and Windows via PyPI. The only strict dependency is NumPy, though Wurlitzer is also installed in order to redirect standard output into Jupyter notebooks in the demos. Simply run the following in a terminal to install Wasserstein: pip3 install wasserstein","title":"Install via pip"},{"location":"installation/#install-from-python-source","text":"The only reason to bother with the source code when using Wasserstein in Python is if one wants to develop some feature in the package. The Wasserstein source code can be obtained from GitHub . Running python3 setup.py swig (which requires the swig binary to be available on the path) will regenerate the Python wrapper code. Running python3 setup.py build_ext --inplace will compile the library, and pip3 install -e . will install a development version pointing to the current directory.","title":"Install from Python source"},{"location":"installation/#c","text":"The Wasserstein source code can be obtained from GitHub . Since the library is header-only, no compilation is required to install it. The provided install_wasserstein.sh script can be used (on a UNIX-like system, at least) to move the requisite header files to an appropriate location such as /usr/local/include . If your system does not have the Boost libraries (version 1.70.0 or newer is required to access the histogram package) available, set the second argument to true in order to use the provided Boost Histogram header files. Try the following in order to move the Wasserstein header files to an installed location, in this case /usr/local/include : git clone https://github.com/pkomiske/Wasserstein cd Wasserstein chmod +x install_wasserstein.sh ./install_wasserstein /usr/local false","title":"C++"},{"location":"releases/","text":"Release Notes 1.1.x 1.1.0 Removed support for Python 3.6. Python 3.10 wheels uploaded to PyPI. Apple silicon arm64 wheels uploaded to PyPI. Enable OpenMP functionality to be toggled on/off, prior to using any Wasserstein functionality, via a lazy import mechanism. Fixed events being modified in place by preprocess_CenterWeightedCentroid . Fixed bug in emd() method of PairwiseEMD when request_mode is enabled. 1.0.x 1.0.1 Small tweaks to C++ API for EventGeometry package. Removing default constructors for CorrelationDimension and Histogram1DUtils from Python. 1.0.0 Many small tweaks to public API; see documentation. C++ examples updated. Float32 functionality now available and tested in Python. 0.3.x Changed symmetric EMD storage from lower triangular to upper triangular to match SciPy's squareform function. 0.3.4 Fixed bug with masking out particles farther than R from the origin. 0.3.3 Wheels are now built against older NumPy versions to facilitate compatibility. 0.3.2 Migrated continuous integration testing and building to travis-ci.com. Changed location of nbins argument to CorrelationDimension to better match boost histogram usage. Building wheels for more architectures now. Using SWIG 4.0.2. 0.3.1 C++ example added. Documentation updated. Small tweaks to some methods. 0.3.0 Changes to some argument names. First version that EnergyFlow is designed to work with. First version with online documentation. 0.2.x 0.2.0 First public version that should have reliable functionality. Tests written that cover most of the code. 0.1.x Rapid testing and development including getting the Python build system on Travis-CI .","title":"Release Notes"},{"location":"releases/#release-notes","text":"","title":"Release Notes"},{"location":"releases/#11x","text":"1.1.0 Removed support for Python 3.6. Python 3.10 wheels uploaded to PyPI. Apple silicon arm64 wheels uploaded to PyPI. Enable OpenMP functionality to be toggled on/off, prior to using any Wasserstein functionality, via a lazy import mechanism. Fixed events being modified in place by preprocess_CenterWeightedCentroid . Fixed bug in emd() method of PairwiseEMD when request_mode is enabled.","title":"1.1.x"},{"location":"releases/#10x","text":"1.0.1 Small tweaks to C++ API for EventGeometry package. Removing default constructors for CorrelationDimension and Histogram1DUtils from Python. 1.0.0 Many small tweaks to public API; see documentation. C++ examples updated. Float32 functionality now available and tested in Python.","title":"1.0.x"},{"location":"releases/#03x","text":"Changed symmetric EMD storage from lower triangular to upper triangular to match SciPy's squareform function. 0.3.4 Fixed bug with masking out particles farther than R from the origin. 0.3.3 Wheels are now built against older NumPy versions to facilitate compatibility. 0.3.2 Migrated continuous integration testing and building to travis-ci.com. Changed location of nbins argument to CorrelationDimension to better match boost histogram usage. Building wheels for more architectures now. Using SWIG 4.0.2. 0.3.1 C++ example added. Documentation updated. Small tweaks to some methods. 0.3.0 Changes to some argument names. First version that EnergyFlow is designed to work with. First version with online documentation.","title":"0.3.x"},{"location":"releases/#02x","text":"0.2.0 First public version that should have reliable functionality. Tests written that cover most of the code.","title":"0.2.x"},{"location":"releases/#01x","text":"Rapid testing and development including getting the Python build system on Travis-CI .","title":"0.1.x"},{"location":"docs/emd/","text":"EMD The EMD class handles computation of individual Wasserstein distances between pairs of distributions. Adopting language from particle physics, we will call the distributions \"events,\" the discrete entities in the ground space \"particles,\" and the particle weights (probability mass) \"energy\". The optimal transport problem can be specified as: \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|, \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|, \\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=\\min\\left(\\sum_{i=1}^ME_i,\\sum_{j=1}^{M'}E^\\prime_j\\right), \\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=\\min\\left(\\sum_{i=1}^ME_i,\\sum_{j=1}^{M'}E^\\prime_j\\right), where \\mathcal E \\mathcal E and \\mathcal E' \\mathcal E' are events with M M and M' M' particles, energies \\{E_i\\} \\{E_i\\} and \\{E'_j\\} \\{E'_j\\} , respectively, and pairwise distance matrix \\theta_{ij} \\theta_{ij} . R>0 R>0 is a parameter controlling the tradeoff between transporting and creating/destroying energy ( R R should be large than half the maximum distance in the ground space in order to ensure the EMD defines a proper metric). \\beta>0 \\beta>0 is an angular exponent, and the EMD only satisfies the triangle inequality for \\beta>1 \\beta>1 if it is raised to the 1/\\beta 1/\\beta power. Python The Python EMD function returns an object (either wasserstein.EMDFloat64 or wasserstein.EMDFloat32 , each of which are instantiations of the C++ template EMD ) that can be used to compute EMD distances. It is designed to work with numpy arrays efficiently. The EMDYPhi function behaves similarly but implements 2\\pi 2\\pi periodicity in the second coordinate dimension, and so is suited for using the rapidity-azimuth plane as a ground space. wasserstein . EMD ( R = 1.0 , beta = 1.0 , norm = False , do_timing = False , n_iter_max = 100000 , epsilon_large_factor = 1000.0 , epsilon_small_factor = 1.0 , dtype = 'float64' ) wasserstein . EMDYPhi ( R = 1.0 , beta = 1.0 , norm = False , do_timing = False , n_iter_max = 100000 , epsilon_large_factor = 1000.0 , epsilon_small_factor = 1.0 , dtype = 'float64' ) Arguments R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. do_timing : bool Whether or not to keep track of the duration of the underlying computation. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogous to epsilon_large_factor but used where the numerical tolerance can be stricter. dtype : one of {'float64', 'float32', numpy.float32, numpy.float64} Controls the floating point precision used in the EMD computation. Run Computation _ _call __ __call__ ( weights0 , coords0 , weights1 , coords1 ) __call__ ( weights0 , weights1 , dists ) Compute the Wasserstein distance between two events using the EMD object. Arguments weights0 : 1d numpy.ndarray The weight values of the first event. weights1 : 1d numpy.ndarray The weight values of the second event. In the first version, the Euclidean ground distance is used where the particle coordinates are specified as: coords0 : 2d numpy.ndarray The Cartesian coordinates of the particles in the first event. If the ground space dimension is d , then it has shape (M0, d) where M0 is the length of weights0 . coords1 : 2d numpy.ndarray The Cartesian coordinates of the particles in the second event. If the ground space dimension is d , then it has shape (M1, d) where M1 is the length of weights1 . In the second version, the ground space distances are provided directly: dists : 2d numpy.ndarray The ground distances between particles in the first and second events. To use the above notation, it has shape (M0, M1) . Returns float The Wasserstein distance between event0 and event1. See also emd() . Access Results These methods access quantities determined during the most recent computation. emd emd () The Wasserstein distance. Returns float The cost of transporting event0 to event1 . dists dists () The ground distances between the particles. Returns numpy.ndarray (first version only) The ground distance matrix as an array with shape (n0, n1) . flows flows () The optimal flow matrix. Returns numpy.ndarray (first version only) The flow matrix as an array with shape (n0, n1) . flow flow ( i , j ) flow ( ind ) First version: Access the flow between particle i in event0 and j in event1 . Note that negative indices are accepted and count from the end, as usual in Python. Second version: Access the flow using a 1D index such that ind = i*n1() + j . Arguments i : int Index of particle in event0 . An IndexError is raised if out of range. j : int Index of particle in event1 . An IndexError is raised if out of range. ind : int Raw flow index, equal to i*n1() + j . Returns float The amount of flow between the specified particles. status status () The status code of the solver. A non-zero value indicates a problem. See the check_emd_status function for interpretting the code. Returns int Networks simplex status code. Zero indicates success, a non-zero value indicates an error. n0 n0 () Number of entities passed to the network simplex solver for event0 . Returns int The number of particles ultimately used in event0 . This may be one greater than the number of given particles in event0 if norm=False and event0 has less total weight than event1 . n1 n1 () Number of entities passed to the network simplex solver for event1 . Returns int The number of particles ultimately used in event1 . This may be one greater than the number of given particles in event1 if norm=False and event1 has less total weight than event0 . extra extra () Which event, if any, got an extra particle. Returns int Which event, 0 or 1 , got an extra particle, or if neither did, -1 . weightdiff weightdiff () Total weight in event1 minus total weight in event0 . Returns float The internally calculated difference in total weight between event1 and event0 . scale scale () The optimal transport problem is internally rescaled in order to provide more numerically stable computations. The scale is the value that the weights are divided by prior to running the network simplex algorithm. Returns float The internally utilized scaling factor for the weights. duration duration () The duration of the core of the optimal transport calculation via the network simplex algorithm. Returns float The time, in seconds, of the computation. If do_timing was not True for this computation then this value is not meaningful. n_iter ````python n_iter() The number of iterations the most recent optimal transport calculation took to finish. **Returns** - _int_ - Number of iterations run by the Network Simplex solver. #### node_potentials ```python node_potentials() The potentials assigned in the Network Simplex algorithm to the particles in each event. Returns ( numpy.ndarray , numpy.ndarray ) A pair of NumPy arrays corresponding to the node potentials in the first and second event. Get/Set Options These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: R() : returns float beta() : returns float norm() : returns bool do_timing : returns bool The setter methods are: set_R(new_R) : accepts float set_beta(new_beta) : accepts float set_norm(new_norm) : accepts bool set_do_timing(new_do_timing) : accepts bool set_network_simplex_params(n_iter_max=100000, epsilon_large_factor=1000.0, epsilon_small_factor=1.0) This method resets all of the underlying network simplex solver's parameters at once. Other Methods preprocess_CenterWeightedCentroid preprocess_CenterWeightedCentroid () This method adds a CenterWeightedCentroid preprocessor to the internal list. The particles of each event will be adjusted so that the origin of the ground space corresponds to their weighted centroid. description description ( write_preprocessors = True ) Returns a string that describes the EMD object. Printing the EMD object uses this method to describe the object. Arguments write_preprocessors : bool Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns string The description of the EMD object. clear clear () Frees some memory in use by the EMD object. This should not normally need to be called by the user. C++ The Wasserstein C++ interface makes heavy use of templates in order to give the user full control over the EMD computation. Most classes are templated to accept a floating point type (either float or double ), though some aliases are provided to make things easier. The EMD class provides the implementation of the EMD as defined above. It accepts four template parameters: a floating point Value type, an Event class, a PairwiseDistance class, and a NetworkSimplex class. The default namespace for the package is wasserstein . template < typename Value , template < typename > class Event = DefaultEvent , template < typename > class PairwiseDistance = DefaultPairwiseDistance , template < typename > class NetworkSimplex = DefaultNetworkSimplex > wasserstein :: EMD ( Value R = 1 , Value beta = 1 , bool norm = false , bool do_timing = false , bool external_dists = false , unsigned n_iter_max = 100000 , Value epsilon_large_factor = 1000 , Value epsilon_small_factor = 1 ); See the Python class of the same name for the meaning of these arguments. external_dists is a new flag indicating whether or not the internal PairwiseDistance object should be used to obtain ground distances or whether the ground distances will be externally provided (see the ground_dists() method below). Ordinarily, users will make use of one of the template specializations of EMD , which only require one to specify an Event and a PairwiseDistance class. These are: // double precision, default NetworkSimplex template < template < typename > class Event = DefaultEvent , template < typename > class PairwiseDistance = DefaultPairwiseDistance > using EMDFloat64 = EMD < double , Event , PairwiseDistance > ; // single precision, default NetworkSimplex template < template < typename > class Event = DefaultEvent , template < typename > class PairwiseDistance = DefaultPairwiseDistance > using EMDFloat32 = EMD < float , Event , PairwiseDistance > ; See the Event and PairwiseDistance docs for more on what classes are provided to fill these roles. Run Computation There are two methods that can be used to compute an EMD distance between two events, operator() and compute . The difference is that the first is templated to accept \"proto events\" (which may be of type Event , or are something that Event can be constructed from) and also preprocesses the events. The second accepts two already constructed events, does not preprocess them, and does not check that their weights have been setup properly. operator() template < class ProtoEvent0 , class ProtoEvent1 > Value operator ()( const ProtoEvent0 & pev0 , const ProtoEvent1 & pev1 ); This version preprocesses each event to ensure any preprocessors are called and the weights are normalized properly (if norm=true ). Arguments pev0 The first event will be constructed by calling Event(pev0) . pev1 The second event will be constructed by calling Event(pev1) . Returns The Wasserstein distance between the two events. compute Value compute ( const Event & ev0 , const Event & ev1 ); This version computes the distance between the two events as they are, without any preprocessing. Arguments ev0 The first event. ev1 The second event. Returns The Wasserstein distance between the two events. ground_dists std :: vector < Value > & ground_dists (); const std :: vector < Value > & ground_dists () const ; To provide external ground distances, one should use this method to access a reference to the vector of distances used by the NetworkSimplex object. The user is free to resize this vector and copy/assign distances into it. Note that if norm=false , then one of the events will generically get an extra particle to account for the difference in weights, and the external dists should account for this. The distances are expected to be provided in row-major (C-style) order. Returns - A (const) reference to the vector of ground distances used by the NetworkSimplex object. Access Results Many of the methods share the same names as the Python ones . These are: Value emd () const ; wasserstein :: EMDStatus status () const ; std :: vector < Value > dists () const ; std :: vector < Value > flows () const ; Value flow ( std :: ptrdiff_t i , std :: ptrdiff_t j ) const ; Value flow ( std :: size_t ind ) const ; std :: ptrdiff_t n0 () const ; std :: ptrdiff_t n1 () const ; wasserstein :: ExtraParticle extra () const ; Value weightdiff () const ; Value scale () const ; double duration () const ; std :: size_t n_iter () const ; std :: pair < std :: vector < Value > , std :: vector < Value >> node_potentials () const ; EMDStatus and ExtraParticle are enums; see the C++ Utils Get/Set Options These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: Value R () const ; Value beta () const ; bool norm () const ; bool do_timing () const ; bool external_dists () const ; const NetworkSimplex & network_simplex () const ; const PairwiseDistance & pairwise_distance () const ; external_dists() indicates whether or not to use the internal PairwiseDistance object or to assume that the ground distances have been externally set. network_simplex() and pairwise_distance() access the underlying objects used to do the heavy lifting of the computation. The setter methods are: void set_R ( Value R ); void set_beta ( Value beta ); void set_norm ( bool norm ); void set_do_timing ( bool do_timing ); void set_external_dists ( bool exdists ); void set_network_simplex_params ( unsigned n_iter_max = 100000 , Value epsilon_large_factor = 1000 , Value epsilon_small_factor = 1 ); Other Methods preprocess template < template < class > class P , typename ... Args > EMD & preprocess ( Args && ... args ) Adds a preprocessor to the internal list. Each event will be preprocessed by the preprocessors in the order they were given. Currently, there is one preprocessor as part of Wasserstein, CenterWeightedCentroid . Since this preprocessor takes no arguments, it can be added as: emd_obj . preprocess < wasserstein :: CenterWeightedCentroid > () In general, any arguments to the preprocessor class are given as arguments to this method. A reference to the EMD object is returned. description std :: string description ( bool write_preprocessors = true ) Returns a string that describes the EMD object. Arguments write_preprocessors Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns The description of the EMD object. clear void clear () Frees some memory in use by the EMD object. This should not normally need to be called by the user.","title":"EMD"},{"location":"docs/emd/#emd","text":"The EMD class handles computation of individual Wasserstein distances between pairs of distributions. Adopting language from particle physics, we will call the distributions \"events,\" the discrete entities in the ground space \"particles,\" and the particle weights (probability mass) \"energy\". The optimal transport problem can be specified as: \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|, \\text{EMD}_{\\beta,R}(\\mathcal E,\\mathcal E^\\prime)=\\min_{\\{f_{ij}\\ge0\\}}\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}\\left(\\frac{ \\theta_{ij}}{R}\\right)^\\beta + \\left|\\sum_{i=1}^ME_i-\\sum_{j=1}^{M'}E^\\prime_j \\right|, \\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=\\min\\left(\\sum_{i=1}^ME_i,\\sum_{j=1}^{M'}E^\\prime_j\\right), \\sum_{j=1}^{M'}f_{ij}\\le E_i, \\quad \\sum_{i=1}^Mf_{ij}\\le E^\\prime_j, \\quad\\sum_{i=1}^M\\sum_{j=1}^{M'}f_{ij}=\\min\\left(\\sum_{i=1}^ME_i,\\sum_{j=1}^{M'}E^\\prime_j\\right), where \\mathcal E \\mathcal E and \\mathcal E' \\mathcal E' are events with M M and M' M' particles, energies \\{E_i\\} \\{E_i\\} and \\{E'_j\\} \\{E'_j\\} , respectively, and pairwise distance matrix \\theta_{ij} \\theta_{ij} . R>0 R>0 is a parameter controlling the tradeoff between transporting and creating/destroying energy ( R R should be large than half the maximum distance in the ground space in order to ensure the EMD defines a proper metric). \\beta>0 \\beta>0 is an angular exponent, and the EMD only satisfies the triangle inequality for \\beta>1 \\beta>1 if it is raised to the 1/\\beta 1/\\beta power.","title":"EMD"},{"location":"docs/emd/#python","text":"The Python EMD function returns an object (either wasserstein.EMDFloat64 or wasserstein.EMDFloat32 , each of which are instantiations of the C++ template EMD ) that can be used to compute EMD distances. It is designed to work with numpy arrays efficiently. The EMDYPhi function behaves similarly but implements 2\\pi 2\\pi periodicity in the second coordinate dimension, and so is suited for using the rapidity-azimuth plane as a ground space. wasserstein . EMD ( R = 1.0 , beta = 1.0 , norm = False , do_timing = False , n_iter_max = 100000 , epsilon_large_factor = 1000.0 , epsilon_small_factor = 1.0 , dtype = 'float64' ) wasserstein . EMDYPhi ( R = 1.0 , beta = 1.0 , norm = False , do_timing = False , n_iter_max = 100000 , epsilon_large_factor = 1000.0 , epsilon_small_factor = 1.0 , dtype = 'float64' ) Arguments R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. do_timing : bool Whether or not to keep track of the duration of the underlying computation. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogous to epsilon_large_factor but used where the numerical tolerance can be stricter. dtype : one of {'float64', 'float32', numpy.float32, numpy.float64} Controls the floating point precision used in the EMD computation.","title":"Python"},{"location":"docs/emd/#run-computation","text":"","title":"Run Computation"},{"location":"docs/emd/#__call__","text":"__call__ ( weights0 , coords0 , weights1 , coords1 ) __call__ ( weights0 , weights1 , dists ) Compute the Wasserstein distance between two events using the EMD object. Arguments weights0 : 1d numpy.ndarray The weight values of the first event. weights1 : 1d numpy.ndarray The weight values of the second event. In the first version, the Euclidean ground distance is used where the particle coordinates are specified as: coords0 : 2d numpy.ndarray The Cartesian coordinates of the particles in the first event. If the ground space dimension is d , then it has shape (M0, d) where M0 is the length of weights0 . coords1 : 2d numpy.ndarray The Cartesian coordinates of the particles in the second event. If the ground space dimension is d , then it has shape (M1, d) where M1 is the length of weights1 . In the second version, the ground space distances are provided directly: dists : 2d numpy.ndarray The ground distances between particles in the first and second events. To use the above notation, it has shape (M0, M1) . Returns float The Wasserstein distance between event0 and event1. See also emd() .","title":"__call__"},{"location":"docs/emd/#access-results","text":"These methods access quantities determined during the most recent computation.","title":"Access Results"},{"location":"docs/emd/#emd_1","text":"emd () The Wasserstein distance. Returns float The cost of transporting event0 to event1 .","title":"emd"},{"location":"docs/emd/#dists","text":"dists () The ground distances between the particles. Returns numpy.ndarray (first version only) The ground distance matrix as an array with shape (n0, n1) .","title":"dists"},{"location":"docs/emd/#flows","text":"flows () The optimal flow matrix. Returns numpy.ndarray (first version only) The flow matrix as an array with shape (n0, n1) .","title":"flows"},{"location":"docs/emd/#flow","text":"flow ( i , j ) flow ( ind ) First version: Access the flow between particle i in event0 and j in event1 . Note that negative indices are accepted and count from the end, as usual in Python. Second version: Access the flow using a 1D index such that ind = i*n1() + j . Arguments i : int Index of particle in event0 . An IndexError is raised if out of range. j : int Index of particle in event1 . An IndexError is raised if out of range. ind : int Raw flow index, equal to i*n1() + j . Returns float The amount of flow between the specified particles.","title":"flow"},{"location":"docs/emd/#status","text":"status () The status code of the solver. A non-zero value indicates a problem. See the check_emd_status function for interpretting the code. Returns int Networks simplex status code. Zero indicates success, a non-zero value indicates an error.","title":"status"},{"location":"docs/emd/#n0","text":"n0 () Number of entities passed to the network simplex solver for event0 . Returns int The number of particles ultimately used in event0 . This may be one greater than the number of given particles in event0 if norm=False and event0 has less total weight than event1 .","title":"n0"},{"location":"docs/emd/#n1","text":"n1 () Number of entities passed to the network simplex solver for event1 . Returns int The number of particles ultimately used in event1 . This may be one greater than the number of given particles in event1 if norm=False and event1 has less total weight than event0 .","title":"n1"},{"location":"docs/emd/#extra","text":"extra () Which event, if any, got an extra particle. Returns int Which event, 0 or 1 , got an extra particle, or if neither did, -1 .","title":"extra"},{"location":"docs/emd/#weightdiff","text":"weightdiff () Total weight in event1 minus total weight in event0 . Returns float The internally calculated difference in total weight between event1 and event0 .","title":"weightdiff"},{"location":"docs/emd/#scale","text":"scale () The optimal transport problem is internally rescaled in order to provide more numerically stable computations. The scale is the value that the weights are divided by prior to running the network simplex algorithm. Returns float The internally utilized scaling factor for the weights.","title":"scale"},{"location":"docs/emd/#duration","text":"duration () The duration of the core of the optimal transport calculation via the network simplex algorithm. Returns float The time, in seconds, of the computation. If do_timing was not True for this computation then this value is not meaningful.","title":"duration"},{"location":"docs/emd/#n_iter","text":"````python n_iter() The number of iterations the most recent optimal transport calculation took to finish. **Returns** - _int_ - Number of iterations run by the Network Simplex solver. #### node_potentials ```python node_potentials() The potentials assigned in the Network Simplex algorithm to the particles in each event. Returns ( numpy.ndarray , numpy.ndarray ) A pair of NumPy arrays corresponding to the node potentials in the first and second event.","title":"n_iter"},{"location":"docs/emd/#getset-options","text":"These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: R() : returns float beta() : returns float norm() : returns bool do_timing : returns bool The setter methods are: set_R(new_R) : accepts float set_beta(new_beta) : accepts float set_norm(new_norm) : accepts bool set_do_timing(new_do_timing) : accepts bool set_network_simplex_params(n_iter_max=100000, epsilon_large_factor=1000.0, epsilon_small_factor=1.0) This method resets all of the underlying network simplex solver's parameters at once.","title":"Get/Set Options"},{"location":"docs/emd/#other-methods","text":"","title":"Other Methods"},{"location":"docs/emd/#preprocess_centerweightedcentroid","text":"preprocess_CenterWeightedCentroid () This method adds a CenterWeightedCentroid preprocessor to the internal list. The particles of each event will be adjusted so that the origin of the ground space corresponds to their weighted centroid.","title":"preprocess_CenterWeightedCentroid"},{"location":"docs/emd/#description","text":"description ( write_preprocessors = True ) Returns a string that describes the EMD object. Printing the EMD object uses this method to describe the object. Arguments write_preprocessors : bool Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns string The description of the EMD object.","title":"description"},{"location":"docs/emd/#clear","text":"clear () Frees some memory in use by the EMD object. This should not normally need to be called by the user.","title":"clear"},{"location":"docs/emd/#c","text":"The Wasserstein C++ interface makes heavy use of templates in order to give the user full control over the EMD computation. Most classes are templated to accept a floating point type (either float or double ), though some aliases are provided to make things easier. The EMD class provides the implementation of the EMD as defined above. It accepts four template parameters: a floating point Value type, an Event class, a PairwiseDistance class, and a NetworkSimplex class. The default namespace for the package is wasserstein . template < typename Value , template < typename > class Event = DefaultEvent , template < typename > class PairwiseDistance = DefaultPairwiseDistance , template < typename > class NetworkSimplex = DefaultNetworkSimplex > wasserstein :: EMD ( Value R = 1 , Value beta = 1 , bool norm = false , bool do_timing = false , bool external_dists = false , unsigned n_iter_max = 100000 , Value epsilon_large_factor = 1000 , Value epsilon_small_factor = 1 ); See the Python class of the same name for the meaning of these arguments. external_dists is a new flag indicating whether or not the internal PairwiseDistance object should be used to obtain ground distances or whether the ground distances will be externally provided (see the ground_dists() method below). Ordinarily, users will make use of one of the template specializations of EMD , which only require one to specify an Event and a PairwiseDistance class. These are: // double precision, default NetworkSimplex template < template < typename > class Event = DefaultEvent , template < typename > class PairwiseDistance = DefaultPairwiseDistance > using EMDFloat64 = EMD < double , Event , PairwiseDistance > ; // single precision, default NetworkSimplex template < template < typename > class Event = DefaultEvent , template < typename > class PairwiseDistance = DefaultPairwiseDistance > using EMDFloat32 = EMD < float , Event , PairwiseDistance > ; See the Event and PairwiseDistance docs for more on what classes are provided to fill these roles.","title":"C++"},{"location":"docs/emd/#run-computation_1","text":"There are two methods that can be used to compute an EMD distance between two events, operator() and compute . The difference is that the first is templated to accept \"proto events\" (which may be of type Event , or are something that Event can be constructed from) and also preprocesses the events. The second accepts two already constructed events, does not preprocess them, and does not check that their weights have been setup properly.","title":"Run Computation"},{"location":"docs/emd/#operator","text":"template < class ProtoEvent0 , class ProtoEvent1 > Value operator ()( const ProtoEvent0 & pev0 , const ProtoEvent1 & pev1 ); This version preprocesses each event to ensure any preprocessors are called and the weights are normalized properly (if norm=true ). Arguments pev0 The first event will be constructed by calling Event(pev0) . pev1 The second event will be constructed by calling Event(pev1) . Returns The Wasserstein distance between the two events.","title":"operator()"},{"location":"docs/emd/#compute","text":"Value compute ( const Event & ev0 , const Event & ev1 ); This version computes the distance between the two events as they are, without any preprocessing. Arguments ev0 The first event. ev1 The second event. Returns The Wasserstein distance between the two events.","title":"compute"},{"location":"docs/emd/#ground_dists","text":"std :: vector < Value > & ground_dists (); const std :: vector < Value > & ground_dists () const ; To provide external ground distances, one should use this method to access a reference to the vector of distances used by the NetworkSimplex object. The user is free to resize this vector and copy/assign distances into it. Note that if norm=false , then one of the events will generically get an extra particle to account for the difference in weights, and the external dists should account for this. The distances are expected to be provided in row-major (C-style) order. Returns - A (const) reference to the vector of ground distances used by the NetworkSimplex object.","title":"ground_dists"},{"location":"docs/emd/#access-results_1","text":"Many of the methods share the same names as the Python ones . These are: Value emd () const ; wasserstein :: EMDStatus status () const ; std :: vector < Value > dists () const ; std :: vector < Value > flows () const ; Value flow ( std :: ptrdiff_t i , std :: ptrdiff_t j ) const ; Value flow ( std :: size_t ind ) const ; std :: ptrdiff_t n0 () const ; std :: ptrdiff_t n1 () const ; wasserstein :: ExtraParticle extra () const ; Value weightdiff () const ; Value scale () const ; double duration () const ; std :: size_t n_iter () const ; std :: pair < std :: vector < Value > , std :: vector < Value >> node_potentials () const ; EMDStatus and ExtraParticle are enums; see the C++ Utils","title":"Access Results"},{"location":"docs/emd/#getset-options_1","text":"These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: Value R () const ; Value beta () const ; bool norm () const ; bool do_timing () const ; bool external_dists () const ; const NetworkSimplex & network_simplex () const ; const PairwiseDistance & pairwise_distance () const ; external_dists() indicates whether or not to use the internal PairwiseDistance object or to assume that the ground distances have been externally set. network_simplex() and pairwise_distance() access the underlying objects used to do the heavy lifting of the computation. The setter methods are: void set_R ( Value R ); void set_beta ( Value beta ); void set_norm ( bool norm ); void set_do_timing ( bool do_timing ); void set_external_dists ( bool exdists ); void set_network_simplex_params ( unsigned n_iter_max = 100000 , Value epsilon_large_factor = 1000 , Value epsilon_small_factor = 1 );","title":"Get/Set Options"},{"location":"docs/emd/#other-methods_1","text":"","title":"Other Methods"},{"location":"docs/emd/#preprocess","text":"template < template < class > class P , typename ... Args > EMD & preprocess ( Args && ... args ) Adds a preprocessor to the internal list. Each event will be preprocessed by the preprocessors in the order they were given. Currently, there is one preprocessor as part of Wasserstein, CenterWeightedCentroid . Since this preprocessor takes no arguments, it can be added as: emd_obj . preprocess < wasserstein :: CenterWeightedCentroid > () In general, any arguments to the preprocessor class are given as arguments to this method. A reference to the EMD object is returned.","title":"preprocess"},{"location":"docs/emd/#description_1","text":"std :: string description ( bool write_preprocessors = true ) Returns a string that describes the EMD object. Arguments write_preprocessors Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns The description of the EMD object.","title":"description"},{"location":"docs/emd/#clear_1","text":"void clear () Frees some memory in use by the EMD object. This should not normally need to be called by the user.","title":"clear"},{"location":"docs/emds/","text":"PairwiseEMD The PairwiseEMD functionality handles the collective computation of Wasserstein distances between pairs of events. Adopting language from particle physics, we will call the distributions \"events,\" the discrete entities in the ground space \"particles,\" and the particle weights (probability mass) \"energy\". It automatically parallelizes the computations across a specified number of threads for the greatest efficiency. Python The Python PairwiseEMD function returns an object (either wasserstein.PairwiseEMDFloat64 or wasserstein.PairwiseEMDFloat32 , each of which are instantiations of the C++ template PairwiseEMD ) that can be used to efficientl compute pairs of EMD distances. It is designed to work with numpy arrays efficiently. The PairwiseEMDYPhi function behaves similarly but implements 2\\pi 2\\pi periodicity in the second coordinate dimension, and so is suited for using the rapidity-azimuth plane as a ground space. wasserstein . PairwiseEMD ( R = 1.0 , beta = 1.0 , norm = False , num_threads =- 1 , print_every =- 10 , verbose = 1 , request_mode = False , store_sym_emds_raw = True , throw_on_error = False , omp_dynamic_chunksize = 10 , n_iter_max = 100000 , epsilon_large_factor = 1000.0 , epsilon_small_factor = 1.0 , dtype = 'float64' ) wasserstein . PairwiseEMDYPhi ( R = 1.0 , beta = 1.0 , norm = False , num_threads =- 1 , print_every =- 10 , verbose = 1 , request_mode = False , store_sym_emds_raw = True , throw_on_error = False , omp_dynamic_chunksize = 10 , n_iter_max = 100000 , epsilon_large_factor = 1000.0 , epsilon_small_factor = 1.0 , dtype = 'float64' ) Arguments R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. num_threads : int The number of threads to use when executing the computations. A value of -1 uses the maximum number according to omp_get_max_threads() and should be used for the greatest efficiency. print_every : int This controls how the slate of EMD computations is divied up. If positive, it is essentially a batch size - i.e. how many computations to do before printing progress (see verbose ), checking for signals, etc., and then continuing. If negative, it is the approximate total number of times to print progress, etc. A value of 0 is equivalent to -1 . Setting this to a small positive number or a large (in absolute value) negative number tends to be inefficient. verbose : int Controls verbosity of the object. All printing is turned off if equal to 0 . Larger numbers turn on successively more printing. Currently there is only one verbosity level but more may be added. For capturing this output in a Jupyter notebook, run %load_ext wurlitzer prior to starting the computation. request_mode : bool Sets up the PairwiseEMD object to accept requests for EMD computations via the emd(i, j) method, rather than computing all EMDs immediately. store_sym_emds_raw : bool Determines whether a symmetric distance matrix is stored square-form (redundant) or vector-form (raw). Wasserstein follows SciPy's convention for vector-form distance matrices. throw_on_error : bool Determines if the computation is interrupted by an error in the EMD calculation, or if the error is handled silently. In all cases, the errors are logged and can be accessed with the error_messages() method. omp_dynamic_chunksize : int Number of EMD computations to spool to each thread at a time. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogous to epsilon_large_factor but used where the numerical tolerance can be stricter. dtype : one of {'float64', 'float32', numpy.float32, numpy.float64} Controls the floating point precision used in the EMD computation. Compute Distances _ _call __ __call__ ( eventsA , eventsB = None , gdim = None , mask = False , event_weightsA = None , event_weightsB = None ) Compute the Wasserstein distances between all pairs of events using the Euclidean ground distance. If eventsB is None then the computations will be between pairs of events drawn from eventsA , otherwise they are between all pairs of events between eventsA and eventsB . Each event should be a two-dimensional numpy array where the first column is the weights and the remaining columns are the coordinates of the particles in the Euclidean ground space. This method does not return anything; see the Access Results section below. Arguments eventsA : { numpy.ndarray , list } of numpy.ndarray The first dataset of events as a list or numpy object array of events. Each event should be a two-dimensional numpy array where the weights are the first column and the Euclidean coordinates are the remaining columns. eventsB : { numpy.ndarray , list } of numpy.ndarray or None A collection of events with the same structure as eventsA , if not None . This may be None in which case the computations are between all pairs of events from eventsA (effectively, eventsB is set equal to eventsA ). gdim : int or None If None , has no effect. If an integer, then this is the dimension of the ground space and the first gdim columns after the first (which contains the weights) are used as the particle coordinates. Concretely, for an event the weights are event[:,0] and the coordinates are #!python event[:,1:gdim+1] . mask : bool If True , then particles farther than R away from the origin of the ground space will be ignored in the EMD computations, where R is the parameter given to the constructor of the PairwiseEMD object. event_weightsA : numpy.ndarray or None Weights to associate to each event in eventsA , used only if an ExternalEMDHandler has been provided which uses event weights. If None , the weight for event is taken to be one. event_weightsS : numpy.ndarray or None Same as event_weightsA but corresponding to eventsB . Access Results These methods access quantities determined during the most recent call to __call__ . emds emds () Matrix of Wasserstein distances as a numpy array. If eventsB was None then this will have shape (nevA, nevA) , otherwise it will have shape (nevA, nevB) . Returns 2d numpy.ndarray Matrix of Wasserstein distances. If eventsB was None then it will be symmetric. raw_emds raw_emds () Vector of Wasserstein distances as a numpy array, of length nevA*(nevA-1)/2 . Throws an error if eventsB was not None . This corresponds to what SciPy terms the vector-form of a square symmetric distance matrix, where the distance between events i and j is given by: \\binom{n}{2}-\\binom{n-i}{2}+(j-i-1) \\binom{n}{2}-\\binom{n-i}{2}+(j-i-1) where n = nevA and i < j . Returns 1d numpy.ndarray Vector of Wasserstein distances. emd emd ( i , j ) The Wasserstein distance between event i from eventsA and event j from eventsB (or eventsA if eventsB is None ). Note that negative indices are accepted and count from the end, as usual in Python. If the PairwiseEMD object is in request mode, then this method is used to trigger the computation of the requested EMD computation. Arguments i : int The index of an event from eventsA . An IndexError is raised if it is out of range. j : int The index of an event from eventsB , or eventsA if eventsB was None . An IndexError is raised if it is out of range. Returns float The Wasserstein distance between the specified events. nevA nevA () Returns int The number of events in dataset A. nevB nevB () If eventsB was None , this will be the same as nevA . Returns int The number of events in dataset B. num_emds num_emds () Returns int The number of unique EMD computations carried out. duration duration () Returns float The wall time, in seconds, of the previous computation. errored errored () Whether or not any individual computations had a non-zero return status, indicating an error. Returns bool Whether any errors occurred among the computations. error_messages error_messages () Error messages, if any, that have occurred during the computations. Returns tuple of str A tuple of the error messages for anything that went wrong during the computations. An empty tuple means there were no errors. Get/Set Options These methods can be used to get the current settings of the PairwiseEMD object or to set new ones. The getter methods are: R() : returns float beta() : returns float norm() : returns bool request_mode() : returns bool omp_dynamic_chunksize() : returns int have_external_emd_handler() : returns bool This will be True if there is an external EMD handler associated with the PairwiseEMD object and False otherwise. storage() : returns int Returns an integer corresponding to an EMDPairsStorage enum value. The setter methods are: set_R(new_R) : accepts float set_beta(new_beta) : accepts float set_norm(new_norm) : accepts bool set_request_mode(new_mode) : accepts bool set_omp_dynamic_chunksize(new_chunksize) : accepts int set_network_simplex_params(n_iter_max=100000, epsilon_large_factor=1000.0, epsilon_small_factor=1.0) This method resets all of the underlying network simplex solver's parameters at once. external_emd_handler set_external_emd_handler ( emd_handler ) Associates this PairwiseEMD object with an ExternalEMDHandler . The results of the EMD computations will not be internally stored but will be passed on to the handler in a thread-safe manner for processing. Arguments emd_handler : ExternalEMDHandler An instance of ExternalEMDHandler that processes EMD values in an online manner. Other Methods preprocess_CenterWeightedCentroid preprocess_CenterWeightedCentroid () This method adds a CenterWeightedCentroid preprocessor to the internal list. The particles of each event will be adjusted so that the origin of the ground space corresponds to their weighted centroid. description description ( write_preprocessors = True ) Returns a string that describes the PairwiseEMD object. Printing the PairwiseEMD object uses this method to describe the object. Arguments write_preprocessors : bool Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns string The description of the PairwiseEMD object. clear clear () Frees some memory in use by the PairwiseEMD object. This should not normally need to be called by the user, except possibly after a larger computation. Note that this also removes any external EMD handler that may be present. C++ The PairwiseEMD C++ class is a template class that accepts a fully-qualified EMD type parameter, from which it obtains information about event types, pairwise distance types, etc. There is a second template parameter which defaults to the value type of the EMD type, but can also be set separately. There are two constructors: one that takes many of the same arguments as the EMD class in order to construct them internally and one that acquires these settings from an EMD object. template < class EMD , typename Value = typename EMD :: value_type > wasserstein :: PairwiseEMD ( Value R = 1 , Value beta = 1 , bool norm = false , int num_threads = -1 , std :: ptrdiff_t print_every = -10 , unsigned verbose = 1 , bool request_mode = false , bool store_sym_emds_raw = true , bool throw_on_error = false , int omp_dynamic_chunksize = 10 , unsigned n_iter_max = 100000 , Value epsilon_large_factor = 1000 , Value epsilon_small_factor = 1 , std :: ostream & os = std :: cout ); template < class EMD > wasserstein :: PairwiseEMD ( const EMD & emd , int num_threads = -1 , std :: ptrdiff_t print_every = -10 , unsigned verbose = 1 , bool store_sym_emds_raw = true , bool throw_on_error = false , int omp_dynamic_chunksize = 10 , std :: ostream & os = std :: cout ) See the Python class of the same name for the meaning of these arguments. os is an output stream that will be used for printing if verbose > 0 . Compute Distances The operator() and compute methods are overloaded to compute collections of EMD distances between two sets of events in different ways. Each has a one-argument version that computes all EMDs between every pair of events in the provided collection. Each also has a two-argument version that computes all EMDs between pairs of events with one from each set. Just as with the EMD methods of the same name, the operator() methods accept \"proto events\" (which may be of type Event or are something that Event can be constructed from) that will be preprocessed and compute accepts fully-constructed events that will not be preprocessed. Events or proto events may be provided as a vector (for both operator() and compute ) or as a first and last iterator ( operator() only) operator() // computes EMDs between pairs of events in one collection, provided as a vector template < class ProtoEvent > void operator ()( const std :: vector < ProtoEvent > & proto_events , const std :: vector < Value > & event_weights = {}); // computes EMDs between pairs of events in one collection, provided as iterators template < class ProtoEventIt > void operator ()( ProtoEventIt proto_events_first , ProtoEventIt proto_events_last , const std :: vector < Value > & event_weights = {}); // computes EMDs between pairs of events in two collections, provided as vectors template < class ProtoEventA , class ProtoEventB > void operator ()( const std :: vector < ProtoEventA > & proto_eventsA , const std :: vector < ProtoEventB > & proto_eventsB , const std :: vector < Value > & event_weightsA = {}, const std :: vector < Value > & event_weightsB = {}); // computes EMDs between pairs of events in two collections, provided as iterators template < class ProtoEventAIt , class ProtoEventBIt > void operator ()( ProtoEventAIt proto_eventsA_first , ProtoEventAIt proto_eventsA_last , ProtoEventBIt proto_eventsB_first , ProtoEventBIt proto_eventsB_last , const std :: vector < Value > & event_weightsA = {}, const std :: vector < Value > & event_weightsB = {}); This version preprocesses each event to ensure any preprocessors are called and the particle weights are normalized properly (if norm = true ). Arguments proto_events[A/B] (vector-style only) Collection of proto events; the actual events will be obtained by calling Event(proto_event) for each proto_event in the vector. proto_events[A/B]_first (iterator-style only) Iterator to first (proto) event. Should be at least a forward iterator. proto_events[A/B]_last (iterator-style only) Iterator pointing to the end of the range of (proto) event . Should be at least a forward iterator. event_weights[A/B] Vector of weights associated to each event; possibly used by an ExternalEMDHandler . If no event weights are provided, each event will be treated as having weight 1. compute void compute ( const std :: vector < Event > & events ); void compute ( const std :: vector < Event > & eventsA , const std :: vector < Event > & eventsB ); This version does not apply any preprocessing. Arguments events[A/B] Vector of fully-constructed events. Access Results Many of the methods share the same names as the Python ones . These are: const std :: vector < Value > & emds ( bool raw = false ); const std :: vector < Event > & events () const ; Value emd ( std :: ptrdiff_t i , std :: ptrdiff_t j ) const ; std :: ptrdiff_t nevA () const ; std :: ptrdiff_t nevB () const ; std :: ptrdiff_t num_emds () const ; wasserstein :: EMDPairsStorage storage () const ; double duration () const ; bool errored () const ; const std :: vector < std :: string > & error_messages () const ; The emds method returns a reference to a vector of the EMD results ( raw = true corresponds to the Python raw_emds method). The events method returns a const reference to the vector of events that was used for the computations. Get/Set Options These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: Value R () const ; Value beta () const ; bool norm () const ; bool have_external_emd_handler () const ; int omp_dynamic_chunksize () const ; bool request_mode () const ; template < class EMDHandler > EMDHandler * external_emd_handler (); The external_emd_handler method accepts one template parameter that is used to dynamically cast the internal pointer to that type. The setter methods are: void set_R ( Value R ); void set_beta ( Value beta ); void set_norm ( bool norm ); void set_external_emd_handler ( ExternalEMDHandler & handler ); void set_omp_dynamic_chunksize ( int chunksize ); void set_request_mode ( bool mode ); void set_network_simplex_params ( unsigned n_iter_max = 100000 , Value epsilon_large_factor = 1000 , Value epsilon_small_factor = 1 ); See External EMD Handlers for more on the provided external EMD handler classes provided in Wasserstein. Other Methods preprocess template < template < class > class P , typename ... Args > PairwiseEMD & preprocess ( Args && ... args ) Adds a preprocessor to the internal list. Each event will be preprocessed by the preprocessors in the order they were given. Currently, there is one preprocessor as part of Wasserstein, CenterWeightedCentroid . Since this preprocessor takes no arguments, it can be added as: pairwise_emd_obj . preprocess < wasserstein :: CenterWeightedCentroid > () In general, any arguments to the preprocessor class are given as arguments to this method. A reference to the PairwiseEMD object is returned. description std :: string description () Returns A string that describes the PairwiseEMD object. clear void clear () Frees some memory in use by the PairwiseEMD object. This should not normally need to be called by the user.","title":"PairwiseEMD"},{"location":"docs/emds/#pairwiseemd","text":"The PairwiseEMD functionality handles the collective computation of Wasserstein distances between pairs of events. Adopting language from particle physics, we will call the distributions \"events,\" the discrete entities in the ground space \"particles,\" and the particle weights (probability mass) \"energy\". It automatically parallelizes the computations across a specified number of threads for the greatest efficiency.","title":"PairwiseEMD"},{"location":"docs/emds/#python","text":"The Python PairwiseEMD function returns an object (either wasserstein.PairwiseEMDFloat64 or wasserstein.PairwiseEMDFloat32 , each of which are instantiations of the C++ template PairwiseEMD ) that can be used to efficientl compute pairs of EMD distances. It is designed to work with numpy arrays efficiently. The PairwiseEMDYPhi function behaves similarly but implements 2\\pi 2\\pi periodicity in the second coordinate dimension, and so is suited for using the rapidity-azimuth plane as a ground space. wasserstein . PairwiseEMD ( R = 1.0 , beta = 1.0 , norm = False , num_threads =- 1 , print_every =- 10 , verbose = 1 , request_mode = False , store_sym_emds_raw = True , throw_on_error = False , omp_dynamic_chunksize = 10 , n_iter_max = 100000 , epsilon_large_factor = 1000.0 , epsilon_small_factor = 1.0 , dtype = 'float64' ) wasserstein . PairwiseEMDYPhi ( R = 1.0 , beta = 1.0 , norm = False , num_threads =- 1 , print_every =- 10 , verbose = 1 , request_mode = False , store_sym_emds_raw = True , throw_on_error = False , omp_dynamic_chunksize = 10 , n_iter_max = 100000 , epsilon_large_factor = 1000.0 , epsilon_small_factor = 1.0 , dtype = 'float64' ) Arguments R : float The R parameter in the EMD definition that controls the relative importance of the two terms. Must be greater than or equal to half of the maximum ground distance in the space in order for the EMD to be a valid metric satisfying the triangle inequality. beta : float The angular weighting exponent. The internal pairwsie distance matrix is raised to this power prior to solving the optimal transport problem. norm : bool Whether or not to normalize the particle weights to sum to one prior to computing the EMD. num_threads : int The number of threads to use when executing the computations. A value of -1 uses the maximum number according to omp_get_max_threads() and should be used for the greatest efficiency. print_every : int This controls how the slate of EMD computations is divied up. If positive, it is essentially a batch size - i.e. how many computations to do before printing progress (see verbose ), checking for signals, etc., and then continuing. If negative, it is the approximate total number of times to print progress, etc. A value of 0 is equivalent to -1 . Setting this to a small positive number or a large (in absolute value) negative number tends to be inefficient. verbose : int Controls verbosity of the object. All printing is turned off if equal to 0 . Larger numbers turn on successively more printing. Currently there is only one verbosity level but more may be added. For capturing this output in a Jupyter notebook, run %load_ext wurlitzer prior to starting the computation. request_mode : bool Sets up the PairwiseEMD object to accept requests for EMD computations via the emd(i, j) method, rather than computing all EMDs immediately. store_sym_emds_raw : bool Determines whether a symmetric distance matrix is stored square-form (redundant) or vector-form (raw). Wasserstein follows SciPy's convention for vector-form distance matrices. throw_on_error : bool Determines if the computation is interrupted by an error in the EMD calculation, or if the error is handled silently. In all cases, the errors are logged and can be accessed with the error_messages() method. omp_dynamic_chunksize : int Number of EMD computations to spool to each thread at a time. n_iter_max : int Maximum number of iterations for solving the optimal transport problem. epsilon_large_factor : float Controls some tolerances in the optimal transport solver. This value is multiplied by the floating points epsilon (around 1e-16 for 64-bit floats) to determine the actual tolerance. epsilon_small_factor : float Analogous to epsilon_large_factor but used where the numerical tolerance can be stricter. dtype : one of {'float64', 'float32', numpy.float32, numpy.float64} Controls the floating point precision used in the EMD computation.","title":"Python"},{"location":"docs/emds/#compute-distances","text":"","title":"Compute Distances"},{"location":"docs/emds/#__call__","text":"__call__ ( eventsA , eventsB = None , gdim = None , mask = False , event_weightsA = None , event_weightsB = None ) Compute the Wasserstein distances between all pairs of events using the Euclidean ground distance. If eventsB is None then the computations will be between pairs of events drawn from eventsA , otherwise they are between all pairs of events between eventsA and eventsB . Each event should be a two-dimensional numpy array where the first column is the weights and the remaining columns are the coordinates of the particles in the Euclidean ground space. This method does not return anything; see the Access Results section below. Arguments eventsA : { numpy.ndarray , list } of numpy.ndarray The first dataset of events as a list or numpy object array of events. Each event should be a two-dimensional numpy array where the weights are the first column and the Euclidean coordinates are the remaining columns. eventsB : { numpy.ndarray , list } of numpy.ndarray or None A collection of events with the same structure as eventsA , if not None . This may be None in which case the computations are between all pairs of events from eventsA (effectively, eventsB is set equal to eventsA ). gdim : int or None If None , has no effect. If an integer, then this is the dimension of the ground space and the first gdim columns after the first (which contains the weights) are used as the particle coordinates. Concretely, for an event the weights are event[:,0] and the coordinates are #!python event[:,1:gdim+1] . mask : bool If True , then particles farther than R away from the origin of the ground space will be ignored in the EMD computations, where R is the parameter given to the constructor of the PairwiseEMD object. event_weightsA : numpy.ndarray or None Weights to associate to each event in eventsA , used only if an ExternalEMDHandler has been provided which uses event weights. If None , the weight for event is taken to be one. event_weightsS : numpy.ndarray or None Same as event_weightsA but corresponding to eventsB .","title":"__call__"},{"location":"docs/emds/#access-results","text":"These methods access quantities determined during the most recent call to __call__ .","title":"Access Results"},{"location":"docs/emds/#emds","text":"emds () Matrix of Wasserstein distances as a numpy array. If eventsB was None then this will have shape (nevA, nevA) , otherwise it will have shape (nevA, nevB) . Returns 2d numpy.ndarray Matrix of Wasserstein distances. If eventsB was None then it will be symmetric.","title":"emds"},{"location":"docs/emds/#raw_emds","text":"raw_emds () Vector of Wasserstein distances as a numpy array, of length nevA*(nevA-1)/2 . Throws an error if eventsB was not None . This corresponds to what SciPy terms the vector-form of a square symmetric distance matrix, where the distance between events i and j is given by: \\binom{n}{2}-\\binom{n-i}{2}+(j-i-1) \\binom{n}{2}-\\binom{n-i}{2}+(j-i-1) where n = nevA and i < j . Returns 1d numpy.ndarray Vector of Wasserstein distances.","title":"raw_emds"},{"location":"docs/emds/#emd","text":"emd ( i , j ) The Wasserstein distance between event i from eventsA and event j from eventsB (or eventsA if eventsB is None ). Note that negative indices are accepted and count from the end, as usual in Python. If the PairwiseEMD object is in request mode, then this method is used to trigger the computation of the requested EMD computation. Arguments i : int The index of an event from eventsA . An IndexError is raised if it is out of range. j : int The index of an event from eventsB , or eventsA if eventsB was None . An IndexError is raised if it is out of range. Returns float The Wasserstein distance between the specified events.","title":"emd"},{"location":"docs/emds/#neva","text":"nevA () Returns int The number of events in dataset A.","title":"nevA"},{"location":"docs/emds/#nevb","text":"nevB () If eventsB was None , this will be the same as nevA . Returns int The number of events in dataset B.","title":"nevB"},{"location":"docs/emds/#num_emds","text":"num_emds () Returns int The number of unique EMD computations carried out.","title":"num_emds"},{"location":"docs/emds/#duration","text":"duration () Returns float The wall time, in seconds, of the previous computation.","title":"duration"},{"location":"docs/emds/#errored","text":"errored () Whether or not any individual computations had a non-zero return status, indicating an error. Returns bool Whether any errors occurred among the computations.","title":"errored"},{"location":"docs/emds/#error_messages","text":"error_messages () Error messages, if any, that have occurred during the computations. Returns tuple of str A tuple of the error messages for anything that went wrong during the computations. An empty tuple means there were no errors.","title":"error_messages"},{"location":"docs/emds/#getset-options","text":"These methods can be used to get the current settings of the PairwiseEMD object or to set new ones. The getter methods are: R() : returns float beta() : returns float norm() : returns bool request_mode() : returns bool omp_dynamic_chunksize() : returns int have_external_emd_handler() : returns bool This will be True if there is an external EMD handler associated with the PairwiseEMD object and False otherwise. storage() : returns int Returns an integer corresponding to an EMDPairsStorage enum value. The setter methods are: set_R(new_R) : accepts float set_beta(new_beta) : accepts float set_norm(new_norm) : accepts bool set_request_mode(new_mode) : accepts bool set_omp_dynamic_chunksize(new_chunksize) : accepts int set_network_simplex_params(n_iter_max=100000, epsilon_large_factor=1000.0, epsilon_small_factor=1.0) This method resets all of the underlying network simplex solver's parameters at once.","title":"Get/Set Options"},{"location":"docs/emds/#external_emd_handler","text":"set_external_emd_handler ( emd_handler ) Associates this PairwiseEMD object with an ExternalEMDHandler . The results of the EMD computations will not be internally stored but will be passed on to the handler in a thread-safe manner for processing. Arguments emd_handler : ExternalEMDHandler An instance of ExternalEMDHandler that processes EMD values in an online manner.","title":"external_emd_handler"},{"location":"docs/emds/#other-methods","text":"","title":"Other Methods"},{"location":"docs/emds/#preprocess_centerweightedcentroid","text":"preprocess_CenterWeightedCentroid () This method adds a CenterWeightedCentroid preprocessor to the internal list. The particles of each event will be adjusted so that the origin of the ground space corresponds to their weighted centroid.","title":"preprocess_CenterWeightedCentroid"},{"location":"docs/emds/#description","text":"description ( write_preprocessors = True ) Returns a string that describes the PairwiseEMD object. Printing the PairwiseEMD object uses this method to describe the object. Arguments write_preprocessors : bool Whether or not to include preprocessors in the description. There are currently no preprocessors included in the Wasserstein package but this may change in the future. Returns string The description of the PairwiseEMD object.","title":"description"},{"location":"docs/emds/#clear","text":"clear () Frees some memory in use by the PairwiseEMD object. This should not normally need to be called by the user, except possibly after a larger computation. Note that this also removes any external EMD handler that may be present.","title":"clear"},{"location":"docs/emds/#c","text":"The PairwiseEMD C++ class is a template class that accepts a fully-qualified EMD type parameter, from which it obtains information about event types, pairwise distance types, etc. There is a second template parameter which defaults to the value type of the EMD type, but can also be set separately. There are two constructors: one that takes many of the same arguments as the EMD class in order to construct them internally and one that acquires these settings from an EMD object. template < class EMD , typename Value = typename EMD :: value_type > wasserstein :: PairwiseEMD ( Value R = 1 , Value beta = 1 , bool norm = false , int num_threads = -1 , std :: ptrdiff_t print_every = -10 , unsigned verbose = 1 , bool request_mode = false , bool store_sym_emds_raw = true , bool throw_on_error = false , int omp_dynamic_chunksize = 10 , unsigned n_iter_max = 100000 , Value epsilon_large_factor = 1000 , Value epsilon_small_factor = 1 , std :: ostream & os = std :: cout ); template < class EMD > wasserstein :: PairwiseEMD ( const EMD & emd , int num_threads = -1 , std :: ptrdiff_t print_every = -10 , unsigned verbose = 1 , bool store_sym_emds_raw = true , bool throw_on_error = false , int omp_dynamic_chunksize = 10 , std :: ostream & os = std :: cout ) See the Python class of the same name for the meaning of these arguments. os is an output stream that will be used for printing if verbose > 0 .","title":"C++"},{"location":"docs/emds/#compute-distances_1","text":"The operator() and compute methods are overloaded to compute collections of EMD distances between two sets of events in different ways. Each has a one-argument version that computes all EMDs between every pair of events in the provided collection. Each also has a two-argument version that computes all EMDs between pairs of events with one from each set. Just as with the EMD methods of the same name, the operator() methods accept \"proto events\" (which may be of type Event or are something that Event can be constructed from) that will be preprocessed and compute accepts fully-constructed events that will not be preprocessed. Events or proto events may be provided as a vector (for both operator() and compute ) or as a first and last iterator ( operator() only)","title":"Compute Distances"},{"location":"docs/emds/#operator","text":"// computes EMDs between pairs of events in one collection, provided as a vector template < class ProtoEvent > void operator ()( const std :: vector < ProtoEvent > & proto_events , const std :: vector < Value > & event_weights = {}); // computes EMDs between pairs of events in one collection, provided as iterators template < class ProtoEventIt > void operator ()( ProtoEventIt proto_events_first , ProtoEventIt proto_events_last , const std :: vector < Value > & event_weights = {}); // computes EMDs between pairs of events in two collections, provided as vectors template < class ProtoEventA , class ProtoEventB > void operator ()( const std :: vector < ProtoEventA > & proto_eventsA , const std :: vector < ProtoEventB > & proto_eventsB , const std :: vector < Value > & event_weightsA = {}, const std :: vector < Value > & event_weightsB = {}); // computes EMDs between pairs of events in two collections, provided as iterators template < class ProtoEventAIt , class ProtoEventBIt > void operator ()( ProtoEventAIt proto_eventsA_first , ProtoEventAIt proto_eventsA_last , ProtoEventBIt proto_eventsB_first , ProtoEventBIt proto_eventsB_last , const std :: vector < Value > & event_weightsA = {}, const std :: vector < Value > & event_weightsB = {}); This version preprocesses each event to ensure any preprocessors are called and the particle weights are normalized properly (if norm = true ). Arguments proto_events[A/B] (vector-style only) Collection of proto events; the actual events will be obtained by calling Event(proto_event) for each proto_event in the vector. proto_events[A/B]_first (iterator-style only) Iterator to first (proto) event. Should be at least a forward iterator. proto_events[A/B]_last (iterator-style only) Iterator pointing to the end of the range of (proto) event . Should be at least a forward iterator. event_weights[A/B] Vector of weights associated to each event; possibly used by an ExternalEMDHandler . If no event weights are provided, each event will be treated as having weight 1.","title":"operator()"},{"location":"docs/emds/#compute","text":"void compute ( const std :: vector < Event > & events ); void compute ( const std :: vector < Event > & eventsA , const std :: vector < Event > & eventsB ); This version does not apply any preprocessing. Arguments events[A/B] Vector of fully-constructed events.","title":"compute"},{"location":"docs/emds/#access-results_1","text":"Many of the methods share the same names as the Python ones . These are: const std :: vector < Value > & emds ( bool raw = false ); const std :: vector < Event > & events () const ; Value emd ( std :: ptrdiff_t i , std :: ptrdiff_t j ) const ; std :: ptrdiff_t nevA () const ; std :: ptrdiff_t nevB () const ; std :: ptrdiff_t num_emds () const ; wasserstein :: EMDPairsStorage storage () const ; double duration () const ; bool errored () const ; const std :: vector < std :: string > & error_messages () const ; The emds method returns a reference to a vector of the EMD results ( raw = true corresponds to the Python raw_emds method). The events method returns a const reference to the vector of events that was used for the computations.","title":"Access Results"},{"location":"docs/emds/#getset-options_1","text":"These methods can be used to get the current settings of the EMD object or to set new ones. The getter methods are: Value R () const ; Value beta () const ; bool norm () const ; bool have_external_emd_handler () const ; int omp_dynamic_chunksize () const ; bool request_mode () const ; template < class EMDHandler > EMDHandler * external_emd_handler (); The external_emd_handler method accepts one template parameter that is used to dynamically cast the internal pointer to that type. The setter methods are: void set_R ( Value R ); void set_beta ( Value beta ); void set_norm ( bool norm ); void set_external_emd_handler ( ExternalEMDHandler & handler ); void set_omp_dynamic_chunksize ( int chunksize ); void set_request_mode ( bool mode ); void set_network_simplex_params ( unsigned n_iter_max = 100000 , Value epsilon_large_factor = 1000 , Value epsilon_small_factor = 1 ); See External EMD Handlers for more on the provided external EMD handler classes provided in Wasserstein.","title":"Get/Set Options"},{"location":"docs/emds/#other-methods_1","text":"","title":"Other Methods"},{"location":"docs/emds/#preprocess","text":"template < template < class > class P , typename ... Args > PairwiseEMD & preprocess ( Args && ... args ) Adds a preprocessor to the internal list. Each event will be preprocessed by the preprocessors in the order they were given. Currently, there is one preprocessor as part of Wasserstein, CenterWeightedCentroid . Since this preprocessor takes no arguments, it can be added as: pairwise_emd_obj . preprocess < wasserstein :: CenterWeightedCentroid > () In general, any arguments to the preprocessor class are given as arguments to this method. A reference to the PairwiseEMD object is returned.","title":"preprocess"},{"location":"docs/emds/#description_1","text":"std :: string description () Returns A string that describes the PairwiseEMD object.","title":"description"},{"location":"docs/emds/#clear_1","text":"void clear () Frees some memory in use by the PairwiseEMD object. This should not normally need to be called by the user.","title":"clear"},{"location":"docs/event/","text":"Events Python In Python, events are provided as NumPy arrays, as described in the EMD and PairwiseEMD sections, and do not need to be directly instantiated. C++ In C++, there is greater flexibility to use different Event classes. An event class should derive from EventBase , which is templated to take two parameters: the WeightCollection and ParticleCollection . A valid WeightCollection should provide a public value_type that is a floating point type. A valid ParticleCollection should provide a public value_type which is the type of an appropriate Particle object. The PairwiseDistance class should be able to calculate pairwise distances between two ParticleCollection objects by iterating over all pairs of Particle s.","title":"Events"},{"location":"docs/event/#events","text":"","title":"Events"},{"location":"docs/event/#python","text":"In Python, events are provided as NumPy arrays, as described in the EMD and PairwiseEMD sections, and do not need to be directly instantiated.","title":"Python"},{"location":"docs/event/#c","text":"In C++, there is greater flexibility to use different Event classes. An event class should derive from EventBase , which is templated to take two parameters: the WeightCollection and ParticleCollection . A valid WeightCollection should provide a public value_type that is a floating point type. A valid ParticleCollection should provide a public value_type which is the type of an appropriate Particle object. The PairwiseDistance class should be able to calculate pairwise distances between two ParticleCollection objects by iterating over all pairs of Particle s.","title":"C++"},{"location":"docs/externalemdhandler/","text":"External EMD Handlers Python ExternalEMDHandler Base class for all external EMD handlers. Cannot be directly instantiated. This takes care of thread safety (when used with PairwiseEMD ) and tracks the number of calls to the handler. In Python, the floating point type is selected by using one of ExternalEMDHandlerFloat64 or ExternalEMDHandlerFloat32 . evaluate evaluate ( * args ) Evaluates the ExternalEMDHandler on a collection of (weighted) EMD values. Arguments *args : one or two numpy.ndarray args[0] should be an array of EMD values. args[1] is optional, but if present it should be the same length as args[0] and is the weight associated with that EMD value (typically the product of the event weights corresponding to that EMD). evaluate_symmetric evaluate_symmetric ( emds , event_weights ) Evaluates the ExternalEMDHandler on a collection of weighted EMD values, where the weights are provided as event weights and the EMDs are provided as the upper-triangular part of a symmetric distance matrix for the events. Arguments emds : numpy.ndarray EMD values between all pairs of events, such as those returned by raw_emds after calling the PairwiseEMD object on a single set of events. Should have length n*(n-1)/2 where n is the number of events. event_weights : numpy.ndarray Event weights for the events the EMDs were computed between. Should be length n . The weight associated to the EMD between events i and j is event_weights[i] * event_weights[j] . call __call__ ( emd , weight = 1 ) Evaluates the ExternalEMDHandler on a single EMD value, optionally weighted. Arguments emd : float The EMD value to process. weight : float The (optional) weight associated to the EMD value. num_calls num_calls () Returns int The number of times that the handler has been called. description description () str A string describing the handler. Histogram1DHandler Histograms the EMD values into a pre-determined histogram. Histogram1DHandler uses a linearly-spaced axis whereas Histogram1DHandlerLog uses a log-spaced axis. The underlying C++ class uses the Boost Histogram Package . wasserstein . Histogram1DHandlerFloat64 ( nbins , axis_min , axis_max ) wasserstein . Histogram1DHandlerFloat32 ( nbins , axis_min , axis_max ) wasserstein . Histogram1DHandlerLogFloat64 ( nbins , axis_min , axis_max ) wasserstein . Histogram1DHandlerLogFloat32 ( nbins , axis_min , axis_max ) The Float64 versions use double-precision and the Float32 versions use single-precision. Arguments nbins : int The number of bins to create in the histogram. axis_min : float The lower bound of the axis. axis_max : float The upper bound of the axis. hist_vals_errs hist_vals_errs ( overflows = True ) This accesses the histogram values and errors (which are the square root of the sum of the squared weights). Arguments overflows : bool Whether or not to include the overflow bins as the first and last entry of the histogram contents and errors. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the values of the histogram and the second is the errors. If overflows is True then each will have length nbins+2 , otherwise they will have length nbins . hist_vals_vars hist_vals_vars ( overflows = True ) This accesses the histogram values and variances (the sum of the squared weights). Arguments overflows : bool Whether or not to include the overflow bins as the first and last entry of the histogram contents and errors. Returns ( numpy.ndarray , numpy.ndarray ) (first version only) A pair of numpy arrays, the first is the values of the histogram and the second is the variances. If overflows is True then each will have length nbins+2 , otherwise they will have length nbins . bin_centers bin_centers () Returns numpy.ndarray The centers of each of the bins as a nbins length numpy array. For the linearly-spaced axis this is the arithmetic mean of the bin edges and for the log-spaced axis this is the geometric mean of the bin edges. bin_edges bin_edges () Returns numpy.ndarray The bin edges as a nbins+1 length numpy array. print_axis print_axis () Returns str A textual representation of the histogram axis. print_hist print_hist () Returns str A textual representation of the histogram. nbins nbins () Returns int The number of bins of the histogram axis. axis_min axis_min () Returns float The lower bound of the histogram axis. axis_max axis_max () Returns float The upper bound of the histogram axis. CorrelationDimension This class inherits from Histogram1DHandlerLog and can be used to compute the correlation dimension of the collection of EMDs. wasserstein . CorrelationDimension ( nbins , axis_min , axis_max , dtype = 'float64' ) Arguments The first threearguments are the same as those of Histogram1DHandlerLog . The dtype argument should be either 'float64' or 'float32' and selects the floating-point precision. corrdims corrdims ( eps = 1e-100 ) Arguments eps : float The epsilon value to use to avoid dividing by zero or taking the log of zero. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the correlation dimension values and the second is the correlation dimension errors. Each of these will be length nbins-1 because a derivative was taken. corrdim_bins corrdim_bins () The EMD bins corresponding to the correlation dimension values and errors returned by corrdims . Returns numpy.ndarray The distance scales of the correlation dimension values. This has length nbins-1 because a derivative was taken. cumulative_vals_vars cumulative_vals_vars () Accesses, the raw cumulative histogram of EMD values and their variances, excluding the overflow bins. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the cumulative EMD histogram values and the second is the variances of these bins. Each of these will be length nbins . C++ ExternalEMDHandler The functionality mirrors that of the Python wrapper. We list here the declarations of the methods of this class: template < typename Value > wasserstein :: ExternalEMDHandler (); virtual std :: string description () const = 0 ; std :: size_t num_calls () const ; void operator ()( Value emd , Value weight = 1 ); void evaluate ( const std :: vector < Value > & emds , const std :: vector < Value > & weights = {}); void evaluate ( const Value * emds , std :: size_t num_emds , const Value * weights = nullptr ); void evaluate_symmetric ( const std :: vector < Value > & emds , const std :: vector < Value > & weights ); void evaluate_symmetric ( const Value * emds , std :: size_t nev , const Value * weights ); protected : virtual void handle ( Value emd , Value weight ) = 0 ; Base classes should implement the description and handle methods. Histogram1DHandler The functionality mirrors that of the Python wrapper. We list here the declarations of the methods of this class: template < class Transform , typename Value > wasserstein :: Histogram1DHandler ( unsigned nbins , Value axis_min , Value axis_max ) unsigned nbins () const ; Value axis_min () const ; Value axis_max () const ; std :: string description () const ; std :: vector < Value > bin_centers () const ; std :: vector < Value > bin_edges () const ; std :: pair < std :: vector < Value > , std :: vector < Value >> hist_vals_vars ( bool overflows = true ) const ; // return textual representations of axis/hist std :: string print_axis () const ; std :: string print_hist () const ; // access underlying boost histogram auto & hist (); auto & axis (); const auto & hist () const ; const auto & axis () const ; CorrelationDimension The functionality mirrors that of the Python wrapper. This class inherits from Histogram1DHandler<boost::histogram::axis::transform::log, Value> . We list here the declarations of the methods of this class: template < typename Value > wasserstein :: CorrelationDimension ( unsigned nbins , Value axis_min , Value axis_max ); std :: pair < std :: vector < Value > , std :: vector < Value >> corrdims ( Value eps = std :: numeric_limits < Value >:: epsilon ()) const ; std :: vector < Value > corrdim_bins () const ; std :: pair < std :: vector < Value > , std :: vector < Value >> cumulative_vals_vars () const ;","title":"External EMD Handlers"},{"location":"docs/externalemdhandler/#external-emd-handlers","text":"","title":"External EMD Handlers"},{"location":"docs/externalemdhandler/#python","text":"","title":"Python"},{"location":"docs/externalemdhandler/#externalemdhandler","text":"Base class for all external EMD handlers. Cannot be directly instantiated. This takes care of thread safety (when used with PairwiseEMD ) and tracks the number of calls to the handler. In Python, the floating point type is selected by using one of ExternalEMDHandlerFloat64 or ExternalEMDHandlerFloat32 .","title":"ExternalEMDHandler"},{"location":"docs/externalemdhandler/#evaluate","text":"evaluate ( * args ) Evaluates the ExternalEMDHandler on a collection of (weighted) EMD values. Arguments *args : one or two numpy.ndarray args[0] should be an array of EMD values. args[1] is optional, but if present it should be the same length as args[0] and is the weight associated with that EMD value (typically the product of the event weights corresponding to that EMD).","title":"evaluate"},{"location":"docs/externalemdhandler/#evaluate_symmetric","text":"evaluate_symmetric ( emds , event_weights ) Evaluates the ExternalEMDHandler on a collection of weighted EMD values, where the weights are provided as event weights and the EMDs are provided as the upper-triangular part of a symmetric distance matrix for the events. Arguments emds : numpy.ndarray EMD values between all pairs of events, such as those returned by raw_emds after calling the PairwiseEMD object on a single set of events. Should have length n*(n-1)/2 where n is the number of events. event_weights : numpy.ndarray Event weights for the events the EMDs were computed between. Should be length n . The weight associated to the EMD between events i and j is event_weights[i] * event_weights[j] .","title":"evaluate_symmetric"},{"location":"docs/externalemdhandler/#call","text":"__call__ ( emd , weight = 1 ) Evaluates the ExternalEMDHandler on a single EMD value, optionally weighted. Arguments emd : float The EMD value to process. weight : float The (optional) weight associated to the EMD value.","title":"call"},{"location":"docs/externalemdhandler/#num_calls","text":"num_calls () Returns int The number of times that the handler has been called.","title":"num_calls"},{"location":"docs/externalemdhandler/#description","text":"description () str A string describing the handler.","title":"description"},{"location":"docs/externalemdhandler/#histogram1dhandler","text":"Histograms the EMD values into a pre-determined histogram. Histogram1DHandler uses a linearly-spaced axis whereas Histogram1DHandlerLog uses a log-spaced axis. The underlying C++ class uses the Boost Histogram Package . wasserstein . Histogram1DHandlerFloat64 ( nbins , axis_min , axis_max ) wasserstein . Histogram1DHandlerFloat32 ( nbins , axis_min , axis_max ) wasserstein . Histogram1DHandlerLogFloat64 ( nbins , axis_min , axis_max ) wasserstein . Histogram1DHandlerLogFloat32 ( nbins , axis_min , axis_max ) The Float64 versions use double-precision and the Float32 versions use single-precision. Arguments nbins : int The number of bins to create in the histogram. axis_min : float The lower bound of the axis. axis_max : float The upper bound of the axis.","title":"Histogram1DHandler"},{"location":"docs/externalemdhandler/#hist_vals_errs","text":"hist_vals_errs ( overflows = True ) This accesses the histogram values and errors (which are the square root of the sum of the squared weights). Arguments overflows : bool Whether or not to include the overflow bins as the first and last entry of the histogram contents and errors. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the values of the histogram and the second is the errors. If overflows is True then each will have length nbins+2 , otherwise they will have length nbins .","title":"hist_vals_errs"},{"location":"docs/externalemdhandler/#hist_vals_vars","text":"hist_vals_vars ( overflows = True ) This accesses the histogram values and variances (the sum of the squared weights). Arguments overflows : bool Whether or not to include the overflow bins as the first and last entry of the histogram contents and errors. Returns ( numpy.ndarray , numpy.ndarray ) (first version only) A pair of numpy arrays, the first is the values of the histogram and the second is the variances. If overflows is True then each will have length nbins+2 , otherwise they will have length nbins .","title":"hist_vals_vars"},{"location":"docs/externalemdhandler/#bin_centers","text":"bin_centers () Returns numpy.ndarray The centers of each of the bins as a nbins length numpy array. For the linearly-spaced axis this is the arithmetic mean of the bin edges and for the log-spaced axis this is the geometric mean of the bin edges.","title":"bin_centers"},{"location":"docs/externalemdhandler/#bin_edges","text":"bin_edges () Returns numpy.ndarray The bin edges as a nbins+1 length numpy array.","title":"bin_edges"},{"location":"docs/externalemdhandler/#print_axis","text":"print_axis () Returns str A textual representation of the histogram axis.","title":"print_axis"},{"location":"docs/externalemdhandler/#print_hist","text":"print_hist () Returns str A textual representation of the histogram.","title":"print_hist"},{"location":"docs/externalemdhandler/#nbins","text":"nbins () Returns int The number of bins of the histogram axis.","title":"nbins"},{"location":"docs/externalemdhandler/#axis_min","text":"axis_min () Returns float The lower bound of the histogram axis.","title":"axis_min"},{"location":"docs/externalemdhandler/#axis_max","text":"axis_max () Returns float The upper bound of the histogram axis.","title":"axis_max"},{"location":"docs/externalemdhandler/#correlationdimension","text":"This class inherits from Histogram1DHandlerLog and can be used to compute the correlation dimension of the collection of EMDs. wasserstein . CorrelationDimension ( nbins , axis_min , axis_max , dtype = 'float64' ) Arguments The first threearguments are the same as those of Histogram1DHandlerLog . The dtype argument should be either 'float64' or 'float32' and selects the floating-point precision.","title":"CorrelationDimension"},{"location":"docs/externalemdhandler/#corrdims","text":"corrdims ( eps = 1e-100 ) Arguments eps : float The epsilon value to use to avoid dividing by zero or taking the log of zero. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the correlation dimension values and the second is the correlation dimension errors. Each of these will be length nbins-1 because a derivative was taken.","title":"corrdims"},{"location":"docs/externalemdhandler/#corrdim_bins","text":"corrdim_bins () The EMD bins corresponding to the correlation dimension values and errors returned by corrdims . Returns numpy.ndarray The distance scales of the correlation dimension values. This has length nbins-1 because a derivative was taken.","title":"corrdim_bins"},{"location":"docs/externalemdhandler/#cumulative_vals_vars","text":"cumulative_vals_vars () Accesses, the raw cumulative histogram of EMD values and their variances, excluding the overflow bins. Returns ( numpy.ndarray , numpy.ndarray ) A pair of numpy arrays, the first is the cumulative EMD histogram values and the second is the variances of these bins. Each of these will be length nbins .","title":"cumulative_vals_vars"},{"location":"docs/externalemdhandler/#c","text":"","title":"C++"},{"location":"docs/externalemdhandler/#externalemdhandler_1","text":"The functionality mirrors that of the Python wrapper. We list here the declarations of the methods of this class: template < typename Value > wasserstein :: ExternalEMDHandler (); virtual std :: string description () const = 0 ; std :: size_t num_calls () const ; void operator ()( Value emd , Value weight = 1 ); void evaluate ( const std :: vector < Value > & emds , const std :: vector < Value > & weights = {}); void evaluate ( const Value * emds , std :: size_t num_emds , const Value * weights = nullptr ); void evaluate_symmetric ( const std :: vector < Value > & emds , const std :: vector < Value > & weights ); void evaluate_symmetric ( const Value * emds , std :: size_t nev , const Value * weights ); protected : virtual void handle ( Value emd , Value weight ) = 0 ; Base classes should implement the description and handle methods.","title":"ExternalEMDHandler"},{"location":"docs/externalemdhandler/#histogram1dhandler_1","text":"The functionality mirrors that of the Python wrapper. We list here the declarations of the methods of this class: template < class Transform , typename Value > wasserstein :: Histogram1DHandler ( unsigned nbins , Value axis_min , Value axis_max ) unsigned nbins () const ; Value axis_min () const ; Value axis_max () const ; std :: string description () const ; std :: vector < Value > bin_centers () const ; std :: vector < Value > bin_edges () const ; std :: pair < std :: vector < Value > , std :: vector < Value >> hist_vals_vars ( bool overflows = true ) const ; // return textual representations of axis/hist std :: string print_axis () const ; std :: string print_hist () const ; // access underlying boost histogram auto & hist (); auto & axis (); const auto & hist () const ; const auto & axis () const ;","title":"Histogram1DHandler"},{"location":"docs/externalemdhandler/#correlationdimension_1","text":"The functionality mirrors that of the Python wrapper. This class inherits from Histogram1DHandler<boost::histogram::axis::transform::log, Value> . We list here the declarations of the methods of this class: template < typename Value > wasserstein :: CorrelationDimension ( unsigned nbins , Value axis_min , Value axis_max ); std :: pair < std :: vector < Value > , std :: vector < Value >> corrdims ( Value eps = std :: numeric_limits < Value >:: epsilon ()) const ; std :: vector < Value > corrdim_bins () const ; std :: pair < std :: vector < Value > , std :: vector < Value >> cumulative_vals_vars () const ;","title":"CorrelationDimension"},{"location":"docs/pairwisedistance/","text":"Pairwise Distances Python In Python, the Euclidean distance is supported as the ground distances between particles. The YPhi versions of the EMD and PairwiseEMD classes implement ground distances in the rapidity-azimuth plane, where the \\phi \\phi coordinate is periodic. C++ In C++, the PairwiseDistance class should be compatible with the ParticleCollection used by the Event class. It should derive from the templated PairwiseDistanceBase class, which uses the CRTP to provide static polymorphism.","title":"Pairwise Distance"},{"location":"docs/pairwisedistance/#pairwise-distances","text":"","title":"Pairwise Distances"},{"location":"docs/pairwisedistance/#python","text":"In Python, the Euclidean distance is supported as the ground distances between particles. The YPhi versions of the EMD and PairwiseEMD classes implement ground distances in the rapidity-azimuth plane, where the \\phi \\phi coordinate is periodic.","title":"Python"},{"location":"docs/pairwisedistance/#c","text":"In C++, the PairwiseDistance class should be compatible with the ParticleCollection used by the Event class. It should derive from the templated PairwiseDistanceBase class, which uses the CRTP to provide static polymorphism.","title":"C++"},{"location":"docs/utils/","text":"Utils Python check_emd_status wasserstein . check_emd_status ( status ) Examines the return status of an EMD computation and raises an appropriate RuntimeError if it is not 0 . See EMDStatus for details acceptable values. Arguments status : int The status of the EMD computation. Zero means success and non-zero values indicate some sort of failure. C++ check_emd_status inline void check_emd_status ( EMDStatus status ); Throws a std::runtime_error with a descriptive message if status is not EMDStatus::Success . EMDStatus Used to indicate the result of running the network simplex algorithm. enum class wasserstein :: EMDStatus : char { Success = 0 , Empty = 1 , SupplyMismatch = 2 , Unbounded = 3 , MaxIterReached = 4 , Infeasible = 5 }; ExtraParticle Used to indicate which event, if any, got an artificial extra particle during an EMD computation. enum class wasserstein :: ExtraParticle : char { Neither = -1 , Zero = 0 , One = 1 }; EMDPairsStorage Used to indicate the type of storage for EMDs in a PairwiseEMD enum class wasserstein :: EMDPairsStorage : char { Full = 0 , FullSymmetric = 1 , FlattenedSymmetric = 2 , External = 3 }; CenterWeightedCentroid Not normally instantiated directly. Used with the templated preprocess method of the EMD and PairwiseEMD classes to adjust all particles so that the weighted centroid is located at the origin.","title":"Utils"},{"location":"docs/utils/#utils","text":"","title":"Utils"},{"location":"docs/utils/#python","text":"","title":"Python"},{"location":"docs/utils/#check_emd_status","text":"wasserstein . check_emd_status ( status ) Examines the return status of an EMD computation and raises an appropriate RuntimeError if it is not 0 . See EMDStatus for details acceptable values. Arguments status : int The status of the EMD computation. Zero means success and non-zero values indicate some sort of failure.","title":"check_emd_status"},{"location":"docs/utils/#c","text":"","title":"C++"},{"location":"docs/utils/#check_emd_status_1","text":"inline void check_emd_status ( EMDStatus status ); Throws a std::runtime_error with a descriptive message if status is not EMDStatus::Success .","title":"check_emd_status"},{"location":"docs/utils/#emdstatus","text":"Used to indicate the result of running the network simplex algorithm. enum class wasserstein :: EMDStatus : char { Success = 0 , Empty = 1 , SupplyMismatch = 2 , Unbounded = 3 , MaxIterReached = 4 , Infeasible = 5 };","title":"EMDStatus"},{"location":"docs/utils/#extraparticle","text":"Used to indicate which event, if any, got an artificial extra particle during an EMD computation. enum class wasserstein :: ExtraParticle : char { Neither = -1 , Zero = 0 , One = 1 };","title":"ExtraParticle"},{"location":"docs/utils/#emdpairsstorage","text":"Used to indicate the type of storage for EMDs in a PairwiseEMD enum class wasserstein :: EMDPairsStorage : char { Full = 0 , FullSymmetric = 1 , FlattenedSymmetric = 2 , External = 3 };","title":"EMDPairsStorage"},{"location":"docs/utils/#centerweightedcentroid","text":"Not normally instantiated directly. Used with the templated preprocess method of the EMD and PairwiseEMD classes to adjust all particles so that the weighted centroid is located at the origin.","title":"CenterWeightedCentroid"}]}
